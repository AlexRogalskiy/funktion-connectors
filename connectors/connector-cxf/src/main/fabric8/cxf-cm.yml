---
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    funktion.fabric8.io/kind: Connector
  name: cxf
data:
  deployment.yml: |
    ---
    apiVersion: extensions/v1beta1
    kind: Deployment
    metadata:
      labels:
        funktion.fabric8.io/kind: Subscription
        connector: cxf
    spec:
      replicas: 1
      template:
        metadata:
          labels:
            funktion.fabric8.io/kind: Subscription
            connector: cxf
        spec:
          containers:
          - image: funktion/connector-cxf:${project.version}
            name: connector
  schema.yml: |
    ---
    component:
      kind: component
      scheme: cxf
      syntax: cxf:beanId:address
      title: CXF
      description: The cxf component is used for SOAP WebServices using Apache CXF.
      label: soap,webservice
      deprecated: false
      async: true
      javaType: org.apache.camel.component.cxf.CxfComponent
      groupId: org.apache.camel
      artifactId: camel-cxf
      version: 2.18.3
    componentProperties:
      allowStreaming:
        kind: property
        type: boolean
        javaType: java.lang.Boolean
        deprecated: false
        secret: false
        description: This option controls whether the CXF component when running in PAYLOAD mode will DOM parse the incoming messages into DOM Elements or keep the payload as a javax.xml.transform.Source object that would allow streaming in some cases.
        order: 0
      headerFilterStrategy:
        kind: property
        type: object
        javaType: org.apache.camel.spi.HeaderFilterStrategy
        deprecated: false
        secret: false
        description: To use a custom HeaderFilterStrategy to filter header to and from Camel message.
        order: 1
    properties:
      beanId:
        kind: path
        group: common
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: 'To lookup an existing configured CxfEndpoint. Must used bean: as
          prefix.'
        order: 0
      address:
        kind: path
        group: service
        label: service
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The service publish address.
        order: 1
      dataFormat:
        kind: parameter
        group: common
        type: string
        javaType: org.apache.camel.component.cxf.DataFormat
        enum:
        - PAYLOAD
        - RAW
        - MESSAGE
        - CXF_MESSAGE
        - POJO
        deprecated: false
        secret: false
        defaultValue: POJO
        description: The data type messages supported by the CXF endpoint.
        order: 2
      wrappedStyle:
        kind: parameter
        group: common
        type: boolean
        javaType: java.lang.Boolean
        deprecated: false
        secret: false
        description: The WSDL style that describes how parameters are represented in the SOAP body. If the value is false CXF will chose the document-literal unwrapped style If the value is true CXF will chose the document-literal wrapped style
        order: 3
      bridgeErrorHandler:
        kind: parameter
        group: consumer
        label: consumer
        type: boolean
        javaType: boolean
        optionalPrefix: consumer.
        deprecated: false
        secret: false
        defaultValue: false
        description: Allows for bridging the consumer to the Camel routing Error Handler which mean any exceptions occurred while the consumer is trying to pickup incoming messages or the likes will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions that will be logged at WARN/ERROR level and ignored.
        order: 4
      exceptionHandler:
        kind: parameter
        group: consumer (advanced)
        label: consumer,advanced
        type: object
        javaType: org.apache.camel.spi.ExceptionHandler
        optionalPrefix: consumer.
        deprecated: false
        secret: false
        description: To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions that will be logged at WARN/ERROR level and ignored.
        order: 5
      exchangePattern:
        kind: parameter
        group: consumer (advanced)
        label: consumer,advanced
        type: string
        javaType: org.apache.camel.ExchangePattern
        enum:
        - InOnly
        - RobustInOnly
        - InOut
        - InOptionalOut
        - OutOnly
        - RobustOutOnly
        - OutIn
        - OutOptionalIn
        deprecated: false
        secret: false
        description: Sets the exchange pattern when the consumer creates an exchange.
        order: 6
      defaultOperationName:
        kind: parameter
        group: producer
        label: producer
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: This option will set the default operationName that will be used by the CxfProducer which invokes the remote service.
        order: 7
      defaultOperationNamespace:
        kind: parameter
        group: producer
        label: producer
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: This option will set the default operationNamespace that will be used by the CxfProducer which invokes the remote service.
        order: 8
      hostnameVerifier:
        kind: parameter
        group: producer
        label: producer
        type: object
        javaType: javax.net.ssl.HostnameVerifier
        deprecated: false
        secret: false
        description: The hostname verifier to be used. Use the notation to reference a HostnameVerifier from the registry.
        order: 9
      sslContextParameters:
        kind: parameter
        group: producer
        label: producer
        type: object
        javaType: org.apache.camel.util.jsse.SSLContextParameters
        deprecated: false
        secret: false
        description: The Camel SSL setting reference. Use the notation to reference the SSL Context.
        order: 10
      wrapped:
        kind: parameter
        group: producer
        label: producer
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Which kind of operation that CXF endpoint producer will invoke
        order: 11
      allowStreaming:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: java.lang.Boolean
        deprecated: false
        secret: false
        description: This option controls whether the CXF component when running in PAYLOAD mode will DOM parse the incoming messages into DOM Elements or keep the payload as a javax.xml.transform.Source object that would allow streaming in some cases.
        order: 12
      bus:
        kind: parameter
        group: advanced
        label: advanced
        type: object
        javaType: org.apache.cxf.Bus
        deprecated: false
        secret: false
        description: To use a custom configured CXF Bus.
        order: 13
      continuationTimeout:
        kind: parameter
        group: advanced
        label: advanced
        type: integer
        javaType: long
        deprecated: false
        secret: false
        defaultValue: "30000"
        description: This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.
        order: 14
      cxfBinding:
        kind: parameter
        group: advanced
        label: advanced
        type: object
        javaType: org.apache.camel.component.cxf.CxfBinding
        deprecated: false
        secret: false
        description: To use a custom CxfBinding to control the binding between Camel Message and CXF Message.
        order: 15
      cxfEndpointConfigurer:
        kind: parameter
        group: advanced
        label: advanced
        type: object
        javaType: org.apache.camel.component.cxf.CxfEndpointConfigurer
        deprecated: false
        secret: false
        description: This option could apply the implementation of org.apache.camel.component.cxf.CxfEndpointConfigurer which supports to configure the CXF endpoint in programmatic way. User can configure the CXF server and client by implementing configureServerClient method of CxfEndpointConfigurer.
        order: 16
      defaultBus:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Will set the default bus when CXF endpoint create a bus by itself
        order: 17
      headerFilterStrategy:
        kind: parameter
        group: advanced
        label: advanced
        type: object
        javaType: org.apache.camel.spi.HeaderFilterStrategy
        deprecated: false
        secret: false
        description: To use a custom HeaderFilterStrategy to filter header to and from Camel message.
        order: 18
      mergeProtocolHeaders:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Whether to merge protocol headers. If enabled then propagating headers between Camel and CXF becomes more consistent and similar. For more details see CAMEL-6393.
        order: 19
      mtomEnabled:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: To enable MTOM (attachments). This requires to use POJO or PAYLOAD data format mode.
        order: 20
      properties:
        kind: parameter
        group: advanced
        label: advanced
        type: object
        javaType: java.util.Map<java.lang.String,java.lang.Object>
        prefix: properties.
        multiValue: true
        deprecated: false
        secret: false
        description: To set additional CXF options using the key/value pairs from the Map. For example to turn on stacktraces in SOAP faults properties.faultStackTraceEnabled=true
        order: 21
      skipPayloadMessagePartCheck:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Sets whether SOAP message validation should be disabled.
        order: 22
      synchronous:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).
        order: 23
      loggingFeatureEnabled:
        kind: parameter
        group: logging
        label: logging
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: This option enables CXF Logging Feature which writes inbound and outbound SOAP messages to log.
        order: 24
      loggingSizeLimit:
        kind: parameter
        group: logging
        label: logging
        type: integer
        javaType: int
        deprecated: false
        secret: false
        defaultValue: "49152"
        description: To limit the total size of number of bytes the logger will output when logging feature has been enabled and -1 for no limit.
        order: 25
      skipFaultLogging:
        kind: parameter
        group: logging
        label: logging
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.
        order: 26
      password:
        kind: parameter
        group: security
        label: security
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: true
        description: This option is used to set the basic authentication information of password for the CXF client.
        order: 27
      username:
        kind: parameter
        group: security
        label: security
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: true
        description: This option is used to set the basic authentication information of username for the CXF client.
        order: 28
      bindingId:
        kind: parameter
        group: service
        label: service
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The bindingId for the service model to use.
        order: 29
      portName:
        kind: parameter
        group: service
        label: service
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The endpoint name this service is implementing it maps to the wsdl:portname. In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.
        order: 30
      publishedEndpointUrl:
        kind: parameter
        group: service
        label: service
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: This option can override the endpointUrl that published from the WSDL which can be accessed with service address url plus wsd
        order: 31
      serviceClass:
        kind: parameter
        group: service
        label: service
        type: string
        javaType: java.lang.Class<?>
        deprecated: false
        secret: false
        description: The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.
        order: 32
      serviceName:
        kind: parameter
        group: service
        label: service
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The service name this service is implementing it maps to the wsdl:servicename.
        order: 33
      wsdlURL:
        kind: parameter
        group: service
        label: service
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The location of the WSDL. Can be on the classpath file system or be hosted remotely.
        order: 34
  documentation.adoc: "[[CXF-CXFComponent]]\nCXF Component\n~~~~~~~~~~~~~\n\nNOTE:When\
    \ using CXF as a consumer, the link:cxf-bean-component.html[CXF Bean\nComponent]\
    \ allows you to factor out how message payloads are received\nfrom their processing\
    \ as a RESTful or SOAP web service. This has the\npotential of using a multitude\
    \ of transports to consume web services.\nThe bean component's configuration is\
    \ also simpler and provides the\nfastest method to implement web services using\
    \ Camel and CXF.\n\nTIP:When using CXF in streaming modes (see DataFormat option),\
    \ then also\nread about link:stream-caching.html[Stream caching].\n\nThe *cxf:*\
    \ component provides integration with\nhttp://cxf.apache.org[Apache CXF] for connecting\
    \ to JAX-WS services\nhosted in CXF.\n\n* link:#CXF-CXFComponent[CXF Component]\n\
    ** link:#CXF-URIformat[URI format]\n** link:#CXF-Options[Options]\n*** link:#CXF-Thedescriptionsofthedataformats[The\
    \ descriptions of the\ndataformats]\n**** link:#CXF-HowtoenableCXFLoggingOutInterceptorinMESSAGEmode[How\
    \ to\nenable CXF's LoggingOutInterceptor in MESSAGE mode]\n*** link:#CXF-DescriptionofrelayHeadersoption[Description\
    \ of\nrelayHeaders option]\n**** link:#CXF-AvailableonlyinPOJOmode[Available only\
    \ in POJO mode]\n**** link:#CXF-ChangessinceRelease2.0[Changes since Release 2.0]\n\
    ** link:#CXF-ConfiguretheCXFendpointswithSpring[Configure the CXF\nendpoints with\
    \ Spring]\n**\nlink:#CXF-ConfiguringtheCXFEndpointswithApacheAriesBlueprint.[Configuring\n\
    the CXF Endpoints with Apache Aries Blueprint.]\n**\nlink:#CXF-Howtomakethecamel-cxfcomponentuselog4jinsteadofjava.util.logging[How\n\
    to make the camel-cxf component use log4j instead of java.util.logging]\n** link:#CXF-Howtoletcamel-cxfresponsemessagewithxmlstartdocument[How\
    \ to\nlet camel-cxf response message with xml start document]\n** link:#CXF-HowtooverridetheCXFproduceraddressfrommessageheader[How\
    \ to\noverride the CXF producer address from message header]\n**\nlink:#CXF-Howtoconsumeamessagefromacamel-cxfendpointinPOJOdataformat[How\n\
    to consume a message from a camel-cxf endpoint in POJO data format]\n**\nlink:#CXF-Howtopreparethemessageforthecamel-cxfendpointinPOJOdataformat[How\n\
    to prepare the message for the camel-cxf endpoint in POJO data format]\n**\nlink:#CXF-Howtodealwiththemessageforacamel-cxfendpointinPAYLOADdataformat[How\n\
    to deal with the message for a camel-cxf endpoint in PAYLOAD data\nformat]\n**\
    \ link:#CXF-HowtogetandsetSOAPheadersinPOJOmode[How to get and set SOAP\nheaders\
    \ in POJO mode]\n** link:#CXF-HowtogetandsetSOAPheadersinPAYLOADmode[How to get\
    \ and set\nSOAP headers in PAYLOAD mode]\n** link:#CXF-SOAPheadersarenotavailableinMESSAGEmode[SOAP\
    \ headers are\nnot available in MESSAGE mode]\n** link:#CXF-HowtothrowaSOAPFaultfromCamel[How\
    \ to throw a SOAP Fault\nfrom Camel]\n**\nlink:#CXF-Howtopropagateacamel-cxfendpointrequestandresponsecontext[How\n\
    to propagate a camel-cxf endpoint's request and response context]\n** link:#CXF-AttachmentSupport[Attachment\
    \ Support]\n** link:#CXF-StreamingSupportinPAYLOADmode[Streaming Support in PAYLOAD\n\
    mode]\n** link:#CXF-UsingthegenericCXFDispatchmode[Using the generic CXF\nDispatch\
    \ mode]\n** link:#CXF-SeeAlso[See Also]\n\nMaven users will need to add the following\
    \ dependency to their `pom.xml`\nfor this component:\n\n[source,xml]\n------------------------------------------------------------\n\
    <dependency>\n    <groupId>org.apache.camel</groupId>\n    <artifactId>camel-cxf</artifactId>\n\
    \    <version>x.x.x</version>\n    <!-- use the same version as your Camel core\
    \ version -->\n</dependency>\n------------------------------------------------------------\n\
    \n[Tip]\n====\nCXF dependencies\n\nIf you want to learn about CXF dependencies\
    \ you can checkout the\n`WHICH-JARS` text file.\n\n====\n\n[[CXF-URIformat]]\n\
    URI format\n^^^^^^^^^^\n\n[source,java]\n------------------------------\ncxf:bean:cxfEndpoint[?options]\n\
    ------------------------------\n\nWhere *cxfEndpoint* represents a bean ID that\
    \ references a bean in the\nSpring bean registry. With this URI format, most of\
    \ the endpoint details\nare specified in the bean definition.\n\n[source,java]\n\
    ---------------------------\ncxf://someAddress[?options]\n---------------------------\n\
    \nWhere *someAddress* specifies the CXF endpoint's address. With this URI\nformat,\
    \ most of the endpoint details are specified using options.\n\nFor either style\
    \ above, you can append options to the URI as follows:\n\n[source,java]\n---------------------------------------------------------------------\n\
    cxf:bean:cxfEndpoint?wsdlURL=wsdl/hello_world.wsdl&dataFormat=PAYLOAD\n---------------------------------------------------------------------\n\
    \n[[CXF-Options]]\nOptions\n^^^^^^^\n\n\n\n// component options: START\nThe CXF\
    \ component supports 2 options which are listed below.\n\n\n\n{% raw %}\n[width=\"\
    100%\",cols=\"2,1m,7\",options=\"header\"]\n|=======================================================================\n\
    | Name | Java Type | Description\n| allowStreaming | Boolean | This option controls\
    \ whether the CXF component when running in PAYLOAD mode will DOM parse the incoming\
    \ messages into DOM Elements or keep the payload as a javax.xml.transform.Source\
    \ object that would allow streaming in some cases.\n| headerFilterStrategy | HeaderFilterStrategy\
    \ | To use a custom HeaderFilterStrategy to filter header to and from Camel message.\n\
    |=======================================================================\n{% endraw\
    \ %}\n// component options: END\n\n\n\n\n\n// endpoint options: START\nThe CXF\
    \ component supports 35 endpoint options which are listed below:\n\n{% raw %}\n\
    [width=\"100%\",cols=\"2,1,1m,1m,5\",options=\"header\"]\n|=======================================================================\n\
    | Name | Group | Default | Java Type | Description\n| beanId | common |  | String\
    \ | To lookup an existing configured CxfEndpoint. Must used bean: as prefix.\n\
    | address | service |  | String | The service publish address.\n| dataFormat |\
    \ common | POJO | DataFormat | The data type messages supported by the CXF endpoint.\n\
    | wrappedStyle | common |  | Boolean | The WSDL style that describes how parameters\
    \ are represented in the SOAP body. If the value is false CXF will chose the document-literal\
    \ unwrapped style If the value is true CXF will chose the document-literal wrapped\
    \ style\n| bridgeErrorHandler | consumer | false | boolean | Allows for bridging\
    \ the consumer to the Camel routing Error Handler which mean any exceptions occurred\
    \ while the consumer is trying to pickup incoming messages or the likes will now\
    \ be processed as a message and handled by the routing Error Handler. By default\
    \ the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with\
    \ exceptions that will be logged at WARN/ERROR level and ignored.\n| exceptionHandler\
    \ | consumer (advanced) |  | ExceptionHandler | To let the consumer use a custom\
    \ ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this\
    \ options is not in use. By default the consumer will deal with exceptions that\
    \ will be logged at WARN/ERROR level and ignored.\n| exchangePattern | consumer\
    \ (advanced) |  | ExchangePattern | Sets the exchange pattern when the consumer\
    \ creates an exchange.\n| defaultOperationName | producer |  | String | This option\
    \ will set the default operationName that will be used by the CxfProducer which\
    \ invokes the remote service.\n| defaultOperationNamespace | producer |  | String\
    \ | This option will set the default operationNamespace that will be used by the\
    \ CxfProducer which invokes the remote service.\n| hostnameVerifier | producer\
    \ |  | HostnameVerifier | The hostname verifier to be used. Use the notation to\
    \ reference a HostnameVerifier from the registry.\n| sslContextParameters | producer\
    \ |  | SSLContextParameters | The Camel SSL setting reference. Use the notation\
    \ to reference the SSL Context.\n| wrapped | producer | false | boolean | Which\
    \ kind of operation that CXF endpoint producer will invoke\n| allowStreaming |\
    \ advanced |  | Boolean | This option controls whether the CXF component when\
    \ running in PAYLOAD mode will DOM parse the incoming messages into DOM Elements\
    \ or keep the payload as a javax.xml.transform.Source object that would allow\
    \ streaming in some cases.\n| bus | advanced |  | Bus | To use a custom configured\
    \ CXF Bus.\n| continuationTimeout | advanced | 30000 | long | This option is used\
    \ to set the CXF continuation timeout which could be used in CxfConsumer by default\
    \ when the CXF server is using Jetty or Servlet transport.\n| cxfBinding | advanced\
    \ |  | CxfBinding | To use a custom CxfBinding to control the binding between\
    \ Camel Message and CXF Message.\n| cxfEndpointConfigurer | advanced |  | CxfEndpointConfigurer\
    \ | This option could apply the implementation of org.apache.camel.component.cxf.CxfEndpointConfigurer\
    \ which supports to configure the CXF endpoint in programmatic way. User can configure\
    \ the CXF server and client by implementing configureServerClient method of CxfEndpointConfigurer.\n\
    | defaultBus | advanced | false | boolean | Will set the default bus when CXF\
    \ endpoint create a bus by itself\n| headerFilterStrategy | advanced |  | HeaderFilterStrategy\
    \ | To use a custom HeaderFilterStrategy to filter header to and from Camel message.\n\
    | mergeProtocolHeaders | advanced | false | boolean | Whether to merge protocol\
    \ headers. If enabled then propagating headers between Camel and CXF becomes more\
    \ consistent and similar. For more details see CAMEL-6393.\n| mtomEnabled | advanced\
    \ | false | boolean | To enable MTOM (attachments). This requires to use POJO\
    \ or PAYLOAD data format mode.\n| properties | advanced |  | Map | To set additional\
    \ CXF options using the key/value pairs from the Map. For example to turn on stacktraces\
    \ in SOAP faults properties.faultStackTraceEnabled=true\n| skipPayloadMessagePartCheck\
    \ | advanced | false | boolean | Sets whether SOAP message validation should be\
    \ disabled.\n| synchronous | advanced | false | boolean | Sets whether synchronous\
    \ processing should be strictly used or Camel is allowed to use asynchronous processing\
    \ (if supported).\n| loggingFeatureEnabled | logging | false | boolean | This\
    \ option enables CXF Logging Feature which writes inbound and outbound SOAP messages\
    \ to log.\n| loggingSizeLimit | logging | 49152 | int | To limit the total size\
    \ of number of bytes the logger will output when logging feature has been enabled\
    \ and -1 for no limit.\n| skipFaultLogging | logging | false | boolean | This\
    \ option controls whether the PhaseInterceptorChain skips logging the Fault that\
    \ it catches.\n| password | security |  | String | This option is used to set\
    \ the basic authentication information of password for the CXF client.\n| username\
    \ | security |  | String | This option is used to set the basic authentication\
    \ information of username for the CXF client.\n| bindingId | service |  | String\
    \ | The bindingId for the service model to use.\n| portName | service |  | String\
    \ | The endpoint name this service is implementing it maps to the wsdl:portname.\
    \ In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.\n\
    | publishedEndpointUrl | service |  | String | This option can override the endpointUrl\
    \ that published from the WSDL which can be accessed with service address url\
    \ plus wsd\n| serviceClass | service |  | Class<?> | The class name of the SEI\
    \ (Service Endpoint Interface) class which could have JSR181 annotation or not.\n\
    | serviceName | service |  | String | The service name this service is implementing\
    \ it maps to the wsdl:servicename.\n| wsdlURL | service |  | String | The location\
    \ of the WSDL. Can be on the classpath file system or be hosted remotely.\n|=======================================================================\n\
    {% endraw %}\n// endpoint options: END\n\n\nThe `serviceName` and `portName` are\n\
    http://en.wikipedia.org/wiki/QName[QNames], so if you provide them be\nsure to\
    \ prefix them with their \\{namespace} as shown in the examples\nabove.\n\n[[CXF-Thedescriptionsofthedataformats]]\n\
    The descriptions of the dataformats\n+++++++++++++++++++++++++++++++++++\n\n[width=\"\
    100%\",cols=\"50%,50%\",options=\"header\",]\n|=======================================================================\n\
    |DataFormat |Description\n\n|`POJO` |POJOs (Plain old Java objects) are the Java\
    \ parameters to the method\nbeing invoked on the target server. Both Protocol\
    \ and Logical JAX-WS\nhandlers are supported.\n\n|`PAYLOAD` |`PAYLOAD` is the\
    \ message payload (the contents of the `soap:body`) after\nmessage configuration\
    \ in the CXF endpoint is applied. Only Protocol\nJAX-WS handler is supported.\
    \ Logical JAX-WS handler is not supported.\n\n|`MESSAGE` |`MESSAGE` is the raw\
    \ message that is received from the transport layer.\nIt is not suppose to touch\
    \ or change Stream, some of the CXF\ninterceptors will be removed if you are using\
    \ this kind of DataFormat so\nyou can't see any soap headers after the camel-cxf\
    \ consumer and JAX-WS\nhandler is not supported.\n\n|`CXF_MESSAGE` |New in *Camel\
    \ 2.8.2*, `CXF_MESSAGE` allows for invoking the full\ncapabilities of CXF interceptors\
    \ by converting the message from the\ntransport layer into a raw SOAP message\n\
    |=======================================================================\n\nYou\
    \ can determine the data format mode of an exchange by retrieving the\nexchange\
    \ property, `CamelCXFDataFormat`. The exchange key constant is\ndefined in\n`org.apache.camel.component.cxf.CxfConstants.DATA_FORMAT_PROPERTY`.\n\
    \n[[CXF-HowtoenableCXFLoggingOutInterceptorinMESSAGEmode]]\nHow to enable CXF's\
    \ LoggingOutInterceptor in MESSAGE mode\n\nCXF's `LoggingOutInterceptor` outputs\
    \ outbound message that goes on the\nwire to logging system (Java Util Logging).\
    \ Since the\n`LoggingOutInterceptor` is in `PRE_STREAM` phase (but `PRE_STREAM`\
    \ phase\nis removed in `MESSAGE` mode), you have to configure\n`LoggingOutInterceptor`\
    \ to be run during the `WRITE` phase. The\nfollowing is an example.\n\n[source,xml]\n\
    -------------------------------------------------------------------------------------------------------\n\
    <bean id=\"loggingOutInterceptor\" class=\"org.apache.cxf.interceptor.LoggingOutInterceptor\"\
    >\n    <!--  it really should have been user-prestream but CXF does have such\
    \ phase! -->\n    <constructor-arg value=\"target/write\"/> \n</bean>\n      \
    \   \n<cxf:cxfEndpoint id=\"serviceEndpoint\" address=\"http://localhost:${CXFTestSupport.port2}/LoggingInterceptorInMessageModeTest/helloworld\"\
    \n    serviceClass=\"org.apache.camel.component.cxf.HelloService\">\n    <cxf:outInterceptors>\n\
    \        <ref bean=\"loggingOutInterceptor\"/>\n    </cxf:outInterceptors>\n \
    \   <cxf:properties>\n        <entry key=\"dataFormat\" value=\"MESSAGE\"/>\n\
    \    </cxf:properties>\n</cxf:cxfEndpoint>\n-------------------------------------------------------------------------------------------------------\n\
    \n[[CXF-DescriptionofrelayHeadersoption]]\nDescription of relayHeaders option\n\
    ++++++++++++++++++++++++++++++++++\n\nThere are _in-band_ and _out-of-band_ on-the-wire\
    \ headers from the\nperspective of a JAXWS WSDL-first developer.\n\nThe _in-band_\
    \ headers are headers that are explicitly defined as part of\nthe WSDL binding\
    \ contract for an endpoint such as SOAP headers.\n\nThe _out-of-band_ headers\
    \ are headers that are serialized over the wire,\nbut are not explicitly part\
    \ of the WSDL binding contract.\n\nHeaders relaying/filtering is bi-directional.\n\
    \nWhen a route has a CXF endpoint and the developer needs to have\non-the-wire\
    \ headers, such as SOAP headers, be relayed along the route to\nbe consumed say\
    \ by another JAXWS endpoint, then `relayHeaders` should be\nset to `true`, which\
    \ is the default value.\n\n[[CXF-AvailableonlyinPOJOmode]]\nAvailable only in\
    \ POJO mode\n\nThe `relayHeaders=true` express an intent to relay the headers.\
    \ The\nactual decision on whether a given header is relayed is delegated to a\n\
    pluggable instance that implements the `MessageHeadersRelay` interface.\nA concrete\
    \ implementation of `MessageHeadersRelay` will be consulted to\ndecide if a header\
    \ needs to be relayed or not. There is already an\nimplementation of `SoapMessageHeadersRelay`\
    \ which binds itself to\nwell-known SOAP name spaces. Currently only out-of-band\
    \ headers are\nfiltered, and in-band headers will always be relayed when\n`relayHeaders=true`.\
    \ If there is a header on the wire, whose name space\nis unknown to the runtime,\
    \ then a fall back `DefaultMessageHeadersRelay`\nwill be used, which simply allows\
    \ all headers to be relayed.\n\nThe `relayHeaders=false` setting asserts that\
    \ all headers in-band and\nout-of-band will be dropped.\n\nYou can plugin your\
    \ own `MessageHeadersRelay` implementations overriding\nor adding additional ones\
    \ to the list of relays. In order to override a\npreloaded relay instance just\
    \ make sure that your `MessageHeadersRelay`\nimplementation services the same\
    \ name spaces as the one you looking to\noverride. Also note, that the overriding\
    \ relay has to service all of the\nname spaces as the one you looking to override,\
    \ or else a runtime\nexception on route start up will be thrown as this would\
    \ introduce an\nambiguity in name spaces to relay instance mappings.\n\n[source,xml]\n\
    -------------------------------------------------------------------------------------------------------\n\
    <cxf:cxfEndpoint ...>\n   <cxf:properties>\n     <entry key=\"org.apache.camel.cxf.message.headers.relays\"\
    >\n       <list>\n         <ref bean=\"customHeadersRelay\"/>\n       </list>\n\
    \     </entry>\n   </cxf:properties>\n </cxf:cxfEndpoint>\n <bean id=\"customHeadersRelay\"\
    \ class=\"org.apache.camel.component.cxf.soap.headers.CustomHeadersRelay\"/>\n\
    -------------------------------------------------------------------------------------------------------\n\
    \nTake a look at the tests that show how you'd be able to relay/drop\nheaders\
    \ here:\n\nhttps://svn.apache.org/repos/asf/camel/branches/camel-1.x/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java[https://svn.apache.org/repos/asf/camel/branches/camel-1.x/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java]\n\
    \n[[CXF-ChangessinceRelease2.0]]\nChanges since Release 2.0\n\n* `POJO` and `PAYLOAD`\
    \ modes are supported. In `POJO` mode, only\nout-of-band message headers are available\
    \ for filtering as the in-band\nheaders have been processed and removed from header\
    \ list by CXF. The\nin-band headers are incorporated into the `MessageContentList`\
    \ in POJO\nmode. The `camel-cxf` component does make any attempt to remove the\n\
    in-band headers from the `MessageContentList`. If filtering of in-band\nheaders\
    \ is required, please use `PAYLOAD` mode or plug in a (pretty\nstraightforward)\
    \ CXF interceptor/JAXWS Handler to the CXF endpoint.\n* The Message Header Relay\
    \ mechanism has been merged into\n`CxfHeaderFilterStrategy`. The `relayHeaders`\
    \ option, its semantics, and\ndefault value remain the same, but it is a property\
    \ of\n`CxfHeaderFilterStrategy`. \n Here is an example of configuring it.\n\n\
    [source,xml]\n-------------------------------------------------------------------------------------------------------\n\
    <bean id=\"dropAllMessageHeadersStrategy\" class=\"org.apache.camel.component.cxf.common.header.CxfHeaderFilterStrategy\"\
    >\n \n    <!--  Set relayHeaders to false to drop all SOAP headers -->\n    <property\
    \ name=\"relayHeaders\" value=\"false\"/>\n     \n</bean>\n-------------------------------------------------------------------------------------------------------\n\
    \nThen, your endpoint can reference the `CxfHeaderFilterStrategy`.\n\n[source,xml]\n\
    -------------------------------------------------------------------------------------------------------\n\
    <route>\n    <from uri=\"cxf:bean:routerNoRelayEndpoint?headerFilterStrategy=#dropAllMessageHeadersStrategy\"\
    />          \n    <to uri=\"cxf:bean:serviceNoRelayEndpoint?headerFilterStrategy=#dropAllMessageHeadersStrategy\"\
    />\n</route>\n-------------------------------------------------------------------------------------------------------\n\
    \n* The `MessageHeadersRelay` interface has changed slightly and has been\nrenamed\
    \ to `MessageHeaderFilter`. It is a property of\n`CxfHeaderFilterStrategy`. Here\
    \ is an example of configuring user\ndefined Message Header Filters:\n\n[source,xml]\n\
    -------------------------------------------------------------------------------------------------------\n\
    <bean id=\"customMessageFilterStrategy\" class=\"org.apache.camel.component.cxf.common.header.CxfHeaderFilterStrategy\"\
    >\n    <property name=\"messageHeaderFilters\">\n        <list>\n            <!--\
    \  SoapMessageHeaderFilter is the built in filter.  It can be removed by omitting\
    \ it. -->\n            <bean class=\"org.apache.camel.component.cxf.common.header.SoapMessageHeaderFilter\"\
    />\n             \n            <!--  Add custom filter here -->   \n         \
    \   <bean class=\"org.apache.camel.component.cxf.soap.headers.CustomHeaderFilter\"\
    />\n        </list>\n    </property>\n</bean>\n-------------------------------------------------------------------------------------------------------\n\
    \n* Other than `relayHeaders`, there are new properties that can be\nconfigured\
    \ in `CxfHeaderFilterStrategy`.\n\n[width=\"100%\",cols=\"10%,10%,80%\",options=\"\
    header\",]\n|=======================================================================\n\
    |Name |Required |Description\n|`relayHeaders` |No |All message headers will be\
    \ processed by Message Header Filters  \n _Type_: `boolean`  \n _Default_: `true`\n\
    \n|`relayAllMessageHeaders` | No |All message headers will be propagated (without\
    \ processing by Message\nHeader Filters)  \n _Type_: `boolean`  \n _Default_:\
    \ `false`\n\n|`allowFilterNamespaceClash` |No |If two filters overlap in activation\
    \ namespace, the property control how\nit should be handled. If the value is `true`,\
    \ last one wins. If the\nvalue is `false`, it will throw an exception  \n _Type_:\
    \ `boolean`  \n _Default_: `false`\n|=======================================================================\n\
    \n[[CXF-ConfiguretheCXFendpointswithSpring]]\nConfigure the CXF endpoints with\
    \ Spring\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou can configure the CXF\
    \ endpoint with the Spring configuration file\nshown below, and you can also embed\
    \ the endpoint into the `camelContext`\ntags. When you are invoking the service\
    \ endpoint, you can set the\n`operationName` and `operationNamespace` headers\
    \ to explicitly state\nwhich operation you are calling.\n\n[source,xml]\n----------------------------------------------------------------------------------------------------------------\n\
    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:cxf=\"http://camel.apache.org/schema/cxf\"\
    \n        xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\
    \ http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://camel.apache.org/schema/cxf\
    \ http://camel.apache.org/schema/cxf/camel-cxf.xsd\n        http://camel.apache.org/schema/spring\
    \ http://camel.apache.org/schema/spring/camel-spring.xsd\">\n     <cxf:cxfEndpoint\
    \ id=\"routerEndpoint\" address=\"http://localhost:9003/CamelContext/RouterPort\"\
    \n            serviceClass=\"org.apache.hello_world_soap_http.GreeterImpl\"/>\n\
    \     <cxf:cxfEndpoint id=\"serviceEndpoint\" address=\"http://localhost:9000/SoapContext/SoapPort\"\
    \n            wsdlURL=\"testutils/hello_world.wsdl\"\n            serviceClass=\"\
    org.apache.hello_world_soap_http.Greeter\"\n            endpointName=\"s:SoapPort\"\
    \n            serviceName=\"s:SOAPService\"\n        xmlns:s=\"http://apache.org/hello_world_soap_http\"\
    \ />\n     <camelContext id=\"camel\" xmlns=\"http://camel.apache.org/schema/spring\"\
    >\n       <route>\n         <from uri=\"cxf:bean:routerEndpoint\" />\n       \
    \  <to uri=\"cxf:bean:serviceEndpoint\" />\n       </route>\n    </camelContext>\n\
    \  </beans>\n----------------------------------------------------------------------------------------------------------------\n\
    \nBe sure to include the JAX-WS `schemaLocation` attribute specified on\nthe root\
    \ beans element. This allows CXF to validate the file and is\nrequired. Also note\
    \ the namespace declarations at the end of the\n`<cxf:cxfEndpoint/>` tag--these\
    \ are required because the combined\n\\{`namespace}localName` syntax is presently\
    \ not supported for this tag's\nattribute values.\n\nThe `cxf:cxfEndpoint` element\
    \ supports many additional attributes:\n\n[width=\"100%\",cols=\"50%,50%\",options=\"\
    header\",]\n|=======================================================================\n\
    |Name |Value\n\n|`PortName` |The endpoint name this service is implementing, it\
    \ maps to the\n`wsdl:port@name`. In the format of `ns:PORT_NAME` where `ns` is\
    \ a\nnamespace prefix valid at this scope.\n\n|`serviceName` |The service name\
    \ this service is implementing, it maps to the\n`wsdl:service@name`. In the format\
    \ of `ns:SERVICE_NAME` where `ns` is a\nnamespace prefix valid at this scope.\n\
    \n|`wsdlURL` |The location of the WSDL. Can be on the classpath, file system,\
    \ or be\nhosted remotely.\n\n|`bindingId` |The `bindingId` for the service model\
    \ to use.\n\n|`address` |The service publish address.\n\n|`bus` |The bus name\
    \ that will be used in the JAX-WS endpoint.\n\n|`serviceClass` |The class name\
    \ of the SEI (Service Endpoint Interface) class which could\nhave JSR181 annotation\
    \ or not.\n|=======================================================================\n\
    \nIt also supports many child elements:\n\n[width=\"100%\",cols=\"50%,50%\",options=\"\
    header\",]\n|=======================================================================\n\
    |Name |Value\n\n|`cxf:inInterceptors` |The incoming interceptors for this endpoint.\
    \ A list of `<bean>` or\n`<ref>`.\n\n|`cxf:inFaultInterceptors` |The incoming\
    \ fault interceptors for this endpoint. A list of `<bean>` or\n`<ref>`.\n\n|`cxf:outInterceptors`\
    \ |The outgoing interceptors for this endpoint. A list of `<bean>` or\n`<ref>`.\n\
    \n|`cxf:outFaultInterceptors` |The outgoing fault interceptors for this endpoint.\
    \ A list of `<bean>` or\n`<ref>`.\n\n|`cxf:properties` | A properties map which\
    \ should be supplied to the JAX-WS endpoint. See\nbelow.\n\n|`cxf:handlers` |A\
    \ JAX-WS handler list which should be supplied to the JAX-WS endpoint.\nSee below.\n\
    \n|`cxf:dataBinding` |You can specify the which `DataBinding` will be use in the\
    \ endpoint.\nThis can be supplied using the Spring `<bean class=\"MyDataBinding\"\
    />`\nsyntax.\n\n|`cxf:binding` |You can specify the `BindingFactory` for this\
    \ endpoint to use. This can\nbe supplied using the Spring `<bean class=\"MyBindingFactory\"\
    />` syntax.\n\n|`cxf:features` |The features that hold the interceptors for this\
    \ endpoint. A list of\nbeans or refs\n\n|`cxf:schemaLocations` |The schema locations\
    \ for endpoint to use. A list of schemaLocations\n\n|`cxf:serviceFactory` |The\
    \ service factory for this endpoint to use. This can be supplied using\nthe Spring\
    \ `<bean class=\"MyServiceFactory\"/>` syntax\n|=======================================================================\n\
    \nYou can find more advanced examples that show how to provide\ninterceptors,\
    \ properties and handlers on the CXF\nhttps://cwiki.apache.org/CXF20DOC/JAX-WS+Configuration[JAX-WS\n\
    Configuration page].\n\n*NOTE* \n You can use cxf:properties to set the camel-cxf\
    \ endpoint's dataFormat\nand setDefaultBus properties from spring configuration\
    \ file.\n\n[source,xml]\n-------------------------------------------------------------------------\n\
    <cxf:cxfEndpoint id=\"testEndpoint\" address=\"http://localhost:9000/router\"\n\
    \     serviceClass=\"org.apache.camel.component.cxf.HelloService\"\n     endpointName=\"\
    s:PortName\"\n     serviceName=\"s:ServiceName\"\n     xmlns:s=\"http://www.example.com/test\"\
    >\n     <cxf:properties>\n       <entry key=\"dataFormat\" value=\"MESSAGE\"/>\n\
    \       <entry key=\"setDefaultBus\" value=\"true\"/>\n     </cxf:properties>\n\
    \   </cxf:cxfEndpoint>\n-------------------------------------------------------------------------\n\
    \n[[CXF-ConfiguringtheCXFEndpointswithApacheAriesBlueprint.]]\nConfiguring the\
    \ CXF Endpoints with Apache Aries Blueprint.\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nSince camel 2.8 there is support for utilizing aries blueprint\ndependency injection\
    \ for your CXF endpoints. \n The schema utilized is very similar to the spring\
    \ schema so the\ntransition is fairly transparent.\n\nExample\n\n[source,xml]\n\
    ------------------------------------------------------------------------------------------------------------------------------------\n\
    <blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n           xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:cm=\"http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0\"\
    \n           xmlns:camel-cxf=\"http://camel.apache.org/schema/blueprint/cxf\"\n\
    \       xmlns:cxfcore=\"http://cxf.apache.org/blueprint/core\"\n           xsi:schemaLocation=\"\
    http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"\
    >\n\n      <camel-cxf:cxfEndpoint id=\"routerEndpoint\"\n                    \
    \ address=\"http://localhost:9001/router\"\n                     serviceClass=\"\
    org.apache.servicemix.examples.cxf.HelloWorld\">\n        <camel-cxf:properties>\n\
    \            <entry key=\"dataFormat\" value=\"MESSAGE\"/>\n        </camel-cxf:properties>\n\
    \     </camel-cxf:cxfEndpoint>\n\n     <camel-cxf:cxfEndpoint id=\"serviceEndpoint\"\
    \n            address=\"http://localhost:9000/SoapContext/SoapPort\"\n       \
    \              serviceClass=\"org.apache.servicemix.examples.cxf.HelloWorld\"\
    >\n    </camel-cxf:cxfEndpoint>\n\n    <camelContext xmlns=\"http://camel.apache.org/schema/blueprint\"\
    >\n        <route>\n            <from uri=\"routerEndpoint\"/>\n            <to\
    \ uri=\"log:request\"/>\n        </route>\n    </camelContext>\n\n</blueprint>\n\
    ------------------------------------------------------------------------------------------------------------------------------------\n\
    \nCurrently the endpoint element is the first supported CXF\nnamespacehandler.\n\
    \nYou can also use the bean references just as in spring\n\n[source,xml]\n----------------------------------------------------------------------------------------------------------------\n\
    <blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n           xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:cm=\"http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0\"\
    \n           xmlns:jaxws=\"http://cxf.apache.org/blueprint/jaxws\"\n         \
    \  xmlns:cxf=\"http://cxf.apache.org/blueprint/core\"\n           xmlns:camel=\"\
    http://camel.apache.org/schema/blueprint\"\n           xmlns:camelcxf=\"http://camel.apache.org/schema/blueprint/cxf\"\
    \n           xsi:schemaLocation=\"\n             http://www.osgi.org/xmlns/blueprint/v1.0.0\
    \ http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n             http://cxf.apache.org/blueprint/jaxws\
    \ http://cxf.apache.org/schemas/blueprint/jaxws.xsd\n             http://cxf.apache.org/blueprint/core\
    \ http://cxf.apache.org/schemas/blueprint/core.xsd\n             \">\n\n    <camelcxf:cxfEndpoint\
    \ id=\"reportIncident\"\n                     address=\"/camel-example-cxf-blueprint/webservices/incident\"\
    \n                     wsdlURL=\"META-INF/wsdl/report_incident.wsdl\"\n      \
    \               serviceClass=\"org.apache.camel.example.reportincident.ReportIncidentEndpoint\"\
    >\n    </camelcxf:cxfEndpoint>\n\n    <bean id=\"reportIncidentRoutes\" class=\"\
    org.apache.camel.example.reportincident.ReportIncidentRoutes\" />\n\n    <camelContext\
    \ xmlns=\"http://camel.apache.org/schema/blueprint\">\n        <routeBuilder ref=\"\
    reportIncidentRoutes\"/>\n    </camelContext>\n\n</blueprint>\n----------------------------------------------------------------------------------------------------------------\n\
    \n[[CXF-Howtomakethecamel-cxfcomponentuselog4jinsteadofjava.util.logging]]\nHow\
    \ to make the camel-cxf component use log4j instead of java.util.logging\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nCXF's default logger is `java.util.logging`. If you want to change it to\nlog4j,\
    \ proceed as follows. Create a file, in the classpath, named\n`META-INF/cxf/org.apache.cxf.logger`.\
    \ This file should contain the\nfully-qualified name of the class,\n`org.apache.cxf.common.logging.Log4jLogger`,\
    \ with no comments, on a\nsingle line.\n\n[[CXF-Howtoletcamel-cxfresponsemessagewithxmlstartdocument]]\n\
    How to let camel-cxf response message with xml start document\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nIf you are using some SOAP client such as PHP, you will get this kind of\nerror,\
    \ because CXF doesn't add the XML start document \"<?xml\nversion=\"1.0\" encoding=\"\
    utf-8\"?>\"\n\n[source,java]\n---------------------------------------------------------------------------------------\n\
    Error:sendSms: SoapFault exception: [Client] looks like we got no XML document\
    \ in [...]\n---------------------------------------------------------------------------------------\n\
    \nTo resolved this issue, you just need to tell StaxOutInterceptor to\nwrite the\
    \ XML start document for you.\n\nYou can add a customer interceptor like this\
    \ and configure it into you\ncamel-cxf endpont\n\nOr adding a message header for\
    \ it like this if you are using *Camel\n2.4*.\n\n[source,java]\n-------------------------------------------------------------------\n\
    \ // set up the response context which force start document\n Map<String, Object>\
    \ map = new HashMap<String, Object>();\n map.put(\"org.apache.cxf.stax.force-start-document\"\
    , Boolean.TRUE);\n exchange.getOut().setHeader(Client.RESPONSE_CONTEXT, map);\n\
    -------------------------------------------------------------------\n\n[[CXF-HowtooverridetheCXFproduceraddressfrommessageheader]]\n\
    How to override the CXF producer address from message header\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nThe\_`camel-cxf`\_producer supports to override the services address by\nsetting\
    \ the message with the key of \"CamelDestinationOverrideUrl\".\n\n[source,java]\n\
    ----------------------------------------------------------------------------------------------\n\
    \ // set up the service address from the message header to override the setting\
    \ of CXF endpoint\n exchange.getIn().setHeader(Exchange.DESTINATION_OVERRIDE_URL,\
    \ constant(getServiceAddress()));\n----------------------------------------------------------------------------------------------\n\
    \n[[CXF-Howtoconsumeamessagefromacamel-cxfendpointinPOJOdataformat]]\nHow to consume\
    \ a message from a camel-cxf endpoint in POJO data format\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nThe `camel-cxf` endpoint consumer POJO data format is based on the\nhttp://cwiki.apache.org/CXF20DOC/invokers.html[cxf\
    \ invoker], so the\nmessage header has a property with the name of\n`CxfConstants.OPERATION_NAME`\
    \ and the message body is a list of the SEI\nmethod parameters.\n\n[[CXF-Howtopreparethemessageforthecamel-cxfendpointinPOJOdataformat]]\n\
    How to prepare the message for the camel-cxf endpoint in POJO data format\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nThe `camel-cxf` endpoint producer is based on the\nhttps://svn.apache.org/repos/asf/cxf/trunk/api/src/main/java/org/apache/cxf/endpoint/Client.java[cxf\n\
    client API]. First you need to specify the operation name in the message\nheader,\
    \ then add the method parameters to a list, and initialize the\nmessage with this\
    \ parameter list. The response message's body is a\nmessageContentsList, you can\
    \ get the result from that list.\n\nIf you don't specify the operation name in\
    \ the message header,\n`CxfProducer` will try to use the `defaultOperationName\
    \ `from\n`CxfEndpoint`, if there is no `defaultOperationName` set on\n`CxfEndpoint`,\
    \ it will pickup the first operationName from the Operation\nlist.\n\nIf you want\
    \ to get the object array from the message body, you can get\nthe body using `message.getbody(Object[].class)`,\
    \ as follows:\n\n[[CXF-Howtodealwiththemessageforacamel-cxfendpointinPAYLOADdataformat]]\n\
    How to deal with the message for a camel-cxf endpoint in PAYLOAD data format\n\
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \n`PAYLOAD` means that you process the payload message from the SOAP\nenvelope.\
    \ You can use the `Header.HEADER_LIST` as the key to set or get\nthe SOAP headers\
    \ and use the `List<Element>` to set or get SOAP body\nelements. \n `Message.getBody()`\
    \ will return an\n`org.apache.camel.component.cxf.CxfPayload` object, which has\
    \ getters\nfor SOAP message headers and Body elements. This change enables\ndecoupling\
    \ the native CXF message from the Camel message.\n\n[[CXF-HowtogetandsetSOAPheadersinPOJOmode]]\n\
    How to get and set SOAP headers in POJO mode\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \n`POJO` means that the data format is a \"list of Java objects\" when the\nCamel-cxf\
    \ endpoint produces or consumes Camel exchanges. Even though\nCamel expose message\
    \ body as POJOs in this mode, Camel-cxf still\nprovides access to read and write\
    \ SOAP headers. However, since CXF\ninterceptors remove in-band SOAP headers from\
    \ Header list after they\nhave been processed, only out-of-band SOAP headers are\
    \ available to\nCamel-cxf in POJO mode.\n\nThe following example illustrate how\
    \ to get/set SOAP headers. Suppose we\nhave a route that forwards from one Camel-cxf\
    \ endpoint to another. That\nis, SOAP Client -> Camel -> CXF service. We can attach\
    \ two processors to\nobtain/insert SOAP headers at (1) before request goes out\
    \ to the CXF\nservice and (2) before response comes back to the SOAP Client. Processor\n\
    (1) and (2) in this example are InsertRequestOutHeaderProcessor and\nInsertResponseOutHeaderProcessor.\
    \ Our route looks like this:\n\nSOAP headers are propagated to and from Camel\
    \ Message headers. The Camel\nmessage header name is \"org.apache.cxf.headers.Header.list\"\
    \ which is a\nconstant defined in CXF (org.apache.cxf.headers.Header.HEADER_LIST).\
    \ The\nheader value is a List of CXF SoapHeader objects\n(org.apache.cxf.binding.soap.SoapHeader).\
    \ The following snippet is the\nInsertResponseOutHeaderProcessor (that insert\
    \ a new SOAP header in the\nresponse message). The way to access SOAP headers\
    \ in both\nInsertResponseOutHeaderProcessor and InsertRequestOutHeaderProcessor\
    \ are\nactually the same. The only difference between the two processors is\n\
    setting the direction of the inserted SOAP header.\n\n[[CXF-HowtogetandsetSOAPheadersinPAYLOADmode]]\n\
    How to get and set SOAP headers in PAYLOAD mode\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nWe've already shown how to access SOAP message (CxfPayload object) in\nPAYLOAD\
    \ mode (See \"How to deal with the message for a camel-cxf endpoint\nin PAYLOAD\
    \ data format\").\n\nOnce you obtain a CxfPayload object, you can invoke the\n\
    CxfPayload.getHeaders() method that returns a List of DOM Elements (SOAP\nheaders).\n\
    \nSince Camel 2.16.0, you can also use the same way as described in\nsub-chapter\
    \ \"How to get and set SOAP headers in POJO mode\" to set or get\nthe SOAP headers.\
    \ So, you can use now the\nheader\_\"org.apache.cxf.headers.Header.list\" to get\
    \ and set a list of\nSOAP headers.This does also mean that if you have a route\_\
    that forwards\nfrom one Camel-cxf endpoint to another (SOAP Client -> Camel ->\
    \ CXF\nservice), now also the SOAP headers sent by the SOAP client are\nforwarded\
    \ to the CXF service. If you do not want that these headers are\nforwarded you\
    \ have to remove them in the Camel header\n\"org.apache.cxf.headers.Header.list\"\
    .\n\n[[CXF-SOAPheadersarenotavailableinMESSAGEmode]]\nSOAP headers are not available\
    \ in MESSAGE mode\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSOAP headers\
    \ are not available in MESSAGE mode as SOAP processing is\nskipped.\n\n[[CXF-HowtothrowaSOAPFaultfromCamel]]\n\
    How to throw a SOAP Fault from Camel\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\
    If you are using a `camel-cxf` endpoint to consume the SOAP request, you\nmay\
    \ need to throw the SOAP Fault from the camel context. +\n Basically, you can\
    \ use the `throwFault` DSL to do that; it works for\n`POJO`, `PAYLOAD` and `MESSAGE`\
    \ data format. +\n You can define the soap fault like this\n\nThen throw it as\
    \ you like\n\nIf your CXF endpoint is working in the `MESSAGE` data format, you\
    \ could\nset the the SOAP Fault message in the message body and set the response\n\
    code in the message header.\n\nSame for using POJO data format. You can set the\
    \ SOAPFault on the out\nbody and also indicate it's a fault by calling Message.setFault(true):\n\
    \n[[CXF-Howtopropagateacamel-cxfendpointrequestandresponsecontext]]\nHow to propagate\
    \ a camel-cxf endpoint's request and response context\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nhttps://svn.apache.org/repos/asf/cxf/trunk/api/src/main/java/org/apache/cxf/endpoint/Client.java[cxf\n\
    client API] provides a way to invoke the operation with request and\nresponse\
    \ context. If you are using a `camel-cxf` endpoint producer to\ninvoke the outside\
    \ web service, you can set the request context and get\nresponse context with\
    \ the following code:\n\n[source,java]\n-------------------------------------------------------------------------------------------------------------\n\
    \        CxfExchange exchange = (CxfExchange)template.send(getJaxwsEndpointUri(),\
    \ new Processor() {\n             public void process(final Exchange exchange)\
    \ {\n                 final List<String> params = new ArrayList<String>();\n \
    \                params.add(TEST_MESSAGE);\n                 // Set the request\
    \ context to the inMessage\n                 Map<String, Object> requestContext\
    \ = new HashMap<String, Object>();\n                 requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,\
    \ JAXWS_SERVER_ADDRESS);\n                 exchange.getIn().setBody(params);\n\
    \                 exchange.getIn().setHeader(Client.REQUEST_CONTEXT , requestContext);\n\
    \                 exchange.getIn().setHeader(CxfConstants.OPERATION_NAME, GREET_ME_OPERATION);\n\
    \             }\n         });\n         org.apache.camel.Message out = exchange.getOut();\n\
    \         // The output is an object array, the first element of the array is\
    \ the return value\n         Object\\[\\] output = out.getBody(Object\\[\\].class);\n\
    \         LOG.info(\"Received output text: \" + output\\[0\\]);\n         // Get\
    \ the response context form outMessage\n         Map<String, Object> responseContext\
    \ = CastUtils.cast((Map)out.getHeader(Client.RESPONSE_CONTEXT));\n         assertNotNull(responseContext);\n\
    \         assertEquals(\"Get the wrong wsdl opertion name\", \"{http://apache.org/hello_world_soap_http}greetMe\"\
    ,\n                      responseContext.get(\"javax.xml.ws.wsdl.operation\").toString());\n\
    -------------------------------------------------------------------------------------------------------------\n\
    \n[[CXF-AttachmentSupport]]\nAttachment Support\n^^^^^^^^^^^^^^^^^^\n\n*POJO Mode:*\
    \ Both SOAP with Attachment and MTOM are supported (see\nexample in Payload Mode\
    \ for enabling MTOM).\_ However, SOAP with\nAttachment is not tested.\_ Since\
    \ attachments are marshalled and\nunmarshalled into POJOs, users typically do\
    \ not need to deal with the\nattachment themself.\_ Attachments are propagated\
    \ to Camel message's\nattachments if the MTOM is not enabled, since 2.12.3.\_\
    \ So, it is\npossible to retreive attachments by Camel Message API\n\n[source,java]\n\
    --------------------------------------------\nDataHandler Message.getAttachment(String\
    \ id)\n--------------------------------------------\n\n*Payload Mode:* MTOM is\
    \ supported since 2.1. Attachments can be\nretrieved by Camel Message APIs mentioned\
    \ above. SOAP with Attachment\n(SwA) is supported and attachments can be retrieved\
    \ since 2.5. SwA is\nthe default (same as setting the CXF endpoint property \"\
    mtom-enabled\" to\nfalse).\_\n\nTo enable MTOM, set the CXF endpoint property\
    \ \"mtom-enabled\" to _true_.\n(I believe you can only do it with Spring.)\n\n\
    You can produce a Camel message with attachment to send to a CXF\nendpoint in\
    \ Payload mode.\n\nYou can also consume a Camel message received from a CXF endpoint\
    \ in\nPayload mode.\n\n*Message Mode:* Attachments are not supported as it does\
    \ not process the\nmessage at all.\n\n*CXF_MESSAGE Mode*: MTOM is supported, and\
    \ Attachments can be retrieved\nby Camel Message APIs mentioned above. Note that\
    \ when receiving a\nmultipart (i.e. MTOM) message the default SOAPMessage to String\n\
    converter will provide the complete multipart payload on the body. If\nyou require\
    \ just the SOAP XML as a String, you can set the message body\nwith message.getSOAPPart(),\
    \ and Camel convert can do the rest of work\nfor you.\n\n[[CXF-StreamingSupportinPAYLOADmode]]\n\
    Streaming Support in PAYLOAD mode\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn 2.8.2,\
    \ the camel-cxf component now supports streaming of incoming\nmessages when using\
    \ PAYLOAD mode. Previously, the incoming messages\nwould have been completely\
    \ DOM parsed. For large messages, this is time\nconsuming and uses a significant\
    \ amount of memory. Starting in 2.8.2,\nthe incoming messages can remain as a\
    \ javax.xml.transform.Source while\nbeing routed and, if nothing modifies the\
    \ payload, can then be directly\nstreamed out to the target destination. For common\
    \ \"simple proxy\" use\ncases (example: from(\"cxf:...\").to(\"cxf:...\")), this\
    \ can provide very\nsignificant performance increases as well as significantly\
    \ lowered\nmemory requirements.\n\nHowever, there are cases where streaming may\
    \ not be appropriate or\ndesired. Due to the streaming nature, invalid incoming\
    \ XML may not be\ncaught until later in the processing chain. Also, certain actions\
    \ may\nrequire the message to be DOM parsed anyway (like WS-Security or message\n\
    tracing and such) in which case the advantages of the streaming is\nlimited. At\
    \ this point, there are two ways to control the streaming:\n\n* Endpoint property:\
    \ you can add \"allowStreaming=false\" as an endpoint\nproperty to turn the streaming\
    \ on/off.\n\n* Component property: the CxfComponent object also has an allowStreaming\n\
    property that can set the default for endpoints created from that\ncomponent.\n\
    \nGlobal system property: you can add a system property of\n\"org.apache.camel.component.cxf.streaming\"\
    \ to \"false\" to turn if off.\nThat sets the global default, but setting the\
    \ endpoint property above\nwill override this value for that endpoint.\n\n[[CXF-UsingthegenericCXFDispatchmode]]\n\
    Using the generic CXF Dispatch mode\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFrom\
    \ 2.8.0, the camel-cxf component supports the generic\nhttps://cxf.apache.org/docs/jax-ws-dispatch-api.html[CXF\
    \ dispatch\nmode]\_that can transport messages of arbitrary structures (i.e.,\
    \ not\nbound to a specific XML schema). To use this mode, you simply omit\nspecifying\
    \ the wsdlURL and serviceClass attributes of the CXF endpoint.\n\n[source,xml]\n\
    -------------------------------------------------------------------------------------------\n\
    <cxf:cxfEndpoint id=\"testEndpoint\" address=\"http://localhost:9000/SoapContext/SoapAnyPort\"\
    >\n     <cxf:properties>\n       <entry key=\"dataFormat\" value=\"PAYLOAD\"/>\n\
    \     </cxf:properties>\n   </cxf:cxfEndpoint>\n-------------------------------------------------------------------------------------------\n\
    \nIt is noted that the default CXF dispatch client does not send a\nspecific SOAPAction\
    \ header. Therefore, when the target service requires\na specific SOAPAction value,\
    \ it is supplied in the Camel header using\nthe key SOAPAction (case-insensitive).\n\
    \n\_\n\n[[CXF-SeeAlso]]\nSee Also\n^^^^^^^^\n\n* link:configuring-camel.html[Configuring\
    \ Camel]\n* link:component.html[Component]\n* link:endpoint.html[Endpoint]\n*\
    \ link:getting-started.html[Getting Started]\n\n"
