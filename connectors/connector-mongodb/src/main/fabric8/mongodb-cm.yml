---
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    funktion.fabric8.io/kind: Connector
  name: mongodb
data:
  deployment.yml: |
    ---
    apiVersion: extensions/v1beta1
    kind: Deployment
    metadata:
      labels:
        funktion.fabric8.io/kind: Subscription
        connector: mongodb
    spec:
      replicas: 1
      template:
        metadata:
          labels:
            funktion.fabric8.io/kind: Subscription
            connector: mongodb
        spec:
          containers:
          - image: funktion/connector-mongodb:${project.version}
            name: connector
  schema.yml: |
    ---
    component:
      kind: component
      scheme: mongodb
      syntax: mongodb:connectionBean
      title: MongoDB
      description: Component for working with documents stored in MongoDB database.
      label: database,nosql
      deprecated: false
      async: false
      javaType: org.apache.camel.component.mongodb.MongoDbComponent
      groupId: org.apache.camel
      artifactId: camel-mongodb
      version: 2.18.3
    componentProperties: {}
    properties:
      connectionBean:
        kind: path
        group: common
        required: true
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: Name of com.mongodb.Mongo to use.
        order: 0
      collection:
        kind: parameter
        group: common
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: Sets the name of the MongoDB collection to bind to this endpoint
        order: 1
      collectionIndex:
        kind: parameter
        group: common
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: 'Sets the collection index (JSON FORMAT : field1 : order1 field2
          : order2)'
        order: 2
      createCollection:
        kind: parameter
        group: common
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: true
        description: Create collection during initialisation if it doesn't exist. Default is true.
        order: 3
      database:
        kind: parameter
        group: common
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: Sets the name of the MongoDB database to target
        order: 4
      operation:
        kind: parameter
        group: common
        type: string
        javaType: org.apache.camel.component.mongodb.MongoDbOperation
        enum:
        - findById
        - findOneByQuery
        - findAll
        - insert
        - save
        - update
        - remove
        - aggregate
        - getDbStats
        - getColStats
        - count
        - command
        deprecated: false
        secret: false
        description: Sets the operation this endpoint will execute against MongoDB. For possible values see MongoDbOperation.
        order: 5
      outputType:
        kind: parameter
        group: common
        type: string
        javaType: org.apache.camel.component.mongodb.MongoDbOutputType
        enum:
        - DBObjectList
        - DBObject
        - DBCursor
        deprecated: false
        secret: false
        description: 'Convert the output of the producer to the selected type : DBObjectList
          DBObject or DBCursor. DBObjectList or DBObject applies to findAll. DBCursor
          applies to all other operations.'
        order: 6
      writeConcern:
        kind: parameter
        group: common
        type: string
        javaType: com.mongodb.WriteConcern
        enum:
        - ACKNOWLEDGED
        - W1
        - W2
        - W3
        - UNACKNOWLEDGED
        - JOURNALED
        - MAJORITY
        - SAFE
        deprecated: false
        secret: false
        defaultValue: ACKNOWLEDGED
        description: Set the WriteConcern for write operations on MongoDB using the standard ones. Resolved from the fields of the WriteConcern class by calling the link WriteConcernvalueOf(String) method.
        order: 7
      bridgeErrorHandler:
        kind: parameter
        group: consumer
        label: consumer
        type: boolean
        javaType: boolean
        optionalPrefix: consumer.
        deprecated: false
        secret: false
        defaultValue: false
        description: Allows for bridging the consumer to the Camel routing Error Handler which mean any exceptions occurred while the consumer is trying to pickup incoming messages or the likes will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions that will be logged at WARN/ERROR level and ignored.
        order: 8
      exceptionHandler:
        kind: parameter
        group: consumer (advanced)
        label: consumer,advanced
        type: object
        javaType: org.apache.camel.spi.ExceptionHandler
        optionalPrefix: consumer.
        deprecated: false
        secret: false
        description: To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions that will be logged at WARN/ERROR level and ignored.
        order: 9
      exchangePattern:
        kind: parameter
        group: consumer (advanced)
        label: consumer,advanced
        type: string
        javaType: org.apache.camel.ExchangePattern
        enum:
        - InOnly
        - RobustInOnly
        - InOut
        - InOptionalOut
        - OutOnly
        - RobustOutOnly
        - OutIn
        - OutOptionalIn
        deprecated: false
        secret: false
        description: Sets the exchange pattern when the consumer creates an exchange.
        order: 10
      cursorRegenerationDelay:
        kind: parameter
        group: advanced
        label: advanced
        type: integer
        javaType: long
        deprecated: false
        secret: false
        defaultValue: "1000"
        description: MongoDB tailable cursors will block until new data arrives. If no new data is inserted after some time the cursor will be automatically freed and closed by the MongoDB server. The client is expected to regenerate the cursor if needed. This value specifies the time to wait before attempting to fetch a new cursor and if the attempt fails how long before the next attempt is made. Default value is 1000ms.
        order: 11
      dynamicity:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Sets whether this endpoint will attempt to dynamically resolve the target database and collection from the incoming Exchange properties. Can be used to override at runtime the database and collection specified on the otherwise static endpoint URI. It is disabled by default to boost performance. Enabling it will take a minimal performance hit.
        order: 12
      readPreference:
        kind: parameter
        group: advanced
        label: advanced
        type: object
        javaType: com.mongodb.ReadPreference
        deprecated: false
        secret: false
        description: Sets a MongoDB ReadPreference on the Mongo connection. Read preferences set directly on the connection will be overridden by this setting. The link com.mongodb.ReadPreferencevalueOf(String) utility method is used to resolve the passed readPreference value. Some examples for the possible values are nearest primary or secondary etc.
        order: 13
      synchronous:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).
        order: 14
      writeResultAsHeader:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: In write operations it determines whether instead of returning WriteResult as the body of the OUT message we transfer the IN message to the OUT and attach the WriteResult as a header.
        order: 15
      persistentId:
        kind: parameter
        group: tail
        label: tail
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: One tail tracking collection can host many trackers for several tailable consumers. To keep them separate each tracker should have its own unique persistentId.
        order: 16
      persistentTailTracking:
        kind: parameter
        group: tail
        label: tail
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Enable persistent tail tracking which is a mechanism to keep track of the last consumed message across system restarts. The next time the system is up the endpoint will recover the cursor from the point where it last stopped slurping records.
        order: 17
      tailTrackCollection:
        kind: parameter
        group: tail
        label: tail
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: Collection where tail tracking information will be persisted. If not specified link MongoDbTailTrackingConfigDEFAULT_COLLECTION will be used by default.
        order: 18
      tailTrackDb:
        kind: parameter
        group: tail
        label: tail
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: Indicates what database the tail tracking mechanism will persist to. If not specified the current database will be picked by default. Dynamicity will not be taken into account even if enabled i.e. the tail tracking database will not vary past endpoint initialisation.
        order: 19
      tailTrackField:
        kind: parameter
        group: tail
        label: tail
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: Field where the last tracked value will be placed. If not specified link MongoDbTailTrackingConfigDEFAULT_FIELD will be used by default.
        order: 20
      tailTrackIncreasingField:
        kind: parameter
        group: tail
        label: tail
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: 'Correlation field in the incoming record which is of increasing
          nature and will be used to position the tailing cursor every time it is generated.
          The cursor will be (re)created with a query of type: tailTrackIncreasingField
          lastValue (possibly recovered from persistent tail tracking). Can be of type
          Integer Date String etc. NOTE: No support for dot notation at the current time
          so the field should be at the top level of the document.'
        order: 21
  documentation.adoc: "[[MongoDB-CamelMongoDBcomponent]]\nCamel MongoDB component\n\
    ~~~~~~~~~~~~~~~~~~~~~~~\n\n*Available as of Camel 2.10*\n\nAccording to Wikipedia:\
    \ \"NoSQL is a movement promoting a loosely defined\nclass of non-relational data\
    \ stores that break with a long history of\nrelational databases and ACID guarantees.\"\
    \ NoSQL solutions have grown in\npopularity in the last few years, and major extremely-used\
    \ sites and\nservices such as Facebook, LinkedIn, Twitter, etc. are known to use\
    \ them\nextensively to achieve scalability and agility.\n\nBasically, NoSQL solutions\
    \ differ from traditional RDBMS (Relational\nDatabase Management Systems) in that\
    \ they don't use SQL as their query\nlanguage and generally don't offer ACID-like\
    \ transactional behaviour nor\nrelational data. Instead, they are designed around\
    \ the concept of\nflexible data structures and schemas (meaning that the traditional\n\
    concept of a database table with a fixed schema is dropped), extreme\nscalability\
    \ on commodity hardware and blazing-fast processing.\n\nMongoDB is a very popular\
    \ NoSQL solution and the camel-mongodb component\nintegrates Camel with MongoDB\
    \ allowing you to interact with MongoDB\ncollections both as a producer (performing\
    \ operations on the collection)\nand as a consumer (consuming documents from a\
    \ MongoDB collection).\n\nMongoDB revolves around the concepts of documents (not\
    \ as is office\ndocuments, but rather hierarchical data defined in JSON/BSON)\
    \ and\ncollections. This component page will assume you are familiar with them.\n\
    Otherwise, visit http://www.mongodb.org/[http://www.mongodb.org/].\n\nMaven users\
    \ will need to add the following dependency to their `pom.xml`\nfor this component:\n\
    \n[source,xml]\n------------------------------------------------------------\n\
    <dependency>\n    <groupId>org.apache.camel</groupId>\n    <artifactId>camel-mongodb</artifactId>\n\
    \    <version>x.y.z</version>\n    <!-- use the same version as your Camel core\
    \ version -->\n</dependency>\n------------------------------------------------------------\n\
    \n[[MongoDB-URIformat]]\nURI format\n~~~~~~~~~~\n\n[source,java]\n---------------------------------------------------------------------------------------------------------------\n\
    mongodb:connectionBean?database=databaseName&collection=collectionName&operation=operationName[&moreOptions...]\n\
    ---------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-options]]\nMongoDB options\n~~~~~~~~~~~~~~~\n\n\n// component options:\
    \ START\nThe MongoDB component has no options.\n// component options: END\n\n\n\
    \n\n\n\n// endpoint options: START\nThe MongoDB component supports 22 endpoint\
    \ options which are listed below:\n\n{% raw %}\n[width=\"100%\",cols=\"2,1,1m,1m,5\"\
    ,options=\"header\"]\n|=======================================================================\n\
    | Name | Group | Default | Java Type | Description\n| connectionBean | common\
    \ |  | String | *Required* Name of com.mongodb.Mongo to use.\n| collection | common\
    \ |  | String | Sets the name of the MongoDB collection to bind to this endpoint\n\
    | collectionIndex | common |  | String | Sets the collection index (JSON FORMAT\
    \ : field1 : order1 field2 : order2)\n| createCollection | common | true | boolean\
    \ | Create collection during initialisation if it doesn't exist. Default is true.\n\
    | database | common |  | String | Sets the name of the MongoDB database to target\n\
    | operation | common |  | MongoDbOperation | Sets the operation this endpoint\
    \ will execute against MongoDB. For possible values see MongoDbOperation.\n| outputType\
    \ | common |  | MongoDbOutputType | Convert the output of the producer to the\
    \ selected type : DBObjectList DBObject or DBCursor. DBObjectList or DBObject\
    \ applies to findAll. DBCursor applies to all other operations.\n| writeConcern\
    \ | common | ACKNOWLEDGED | WriteConcern | Set the WriteConcern for write operations\
    \ on MongoDB using the standard ones. Resolved from the fields of the WriteConcern\
    \ class by calling the link WriteConcernvalueOf(String) method.\n| bridgeErrorHandler\
    \ | consumer | false | boolean | Allows for bridging the consumer to the Camel\
    \ routing Error Handler which mean any exceptions occurred while the consumer\
    \ is trying to pickup incoming messages or the likes will now be processed as\
    \ a message and handled by the routing Error Handler. By default the consumer\
    \ will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions that\
    \ will be logged at WARN/ERROR level and ignored.\n| exceptionHandler | consumer\
    \ (advanced) |  | ExceptionHandler | To let the consumer use a custom ExceptionHandler.\
    \ Notice if the option bridgeErrorHandler is enabled then this options is not\
    \ in use. By default the consumer will deal with exceptions that will be logged\
    \ at WARN/ERROR level and ignored.\n| exchangePattern | consumer (advanced) |\
    \  | ExchangePattern | Sets the exchange pattern when the consumer creates an\
    \ exchange.\n| cursorRegenerationDelay | advanced | 1000 | long | MongoDB tailable\
    \ cursors will block until new data arrives. If no new data is inserted after\
    \ some time the cursor will be automatically freed and closed by the MongoDB server.\
    \ The client is expected to regenerate the cursor if needed. This value specifies\
    \ the time to wait before attempting to fetch a new cursor and if the attempt\
    \ fails how long before the next attempt is made. Default value is 1000ms.\n|\
    \ dynamicity | advanced | false | boolean | Sets whether this endpoint will attempt\
    \ to dynamically resolve the target database and collection from the incoming\
    \ Exchange properties. Can be used to override at runtime the database and collection\
    \ specified on the otherwise static endpoint URI. It is disabled by default to\
    \ boost performance. Enabling it will take a minimal performance hit.\n| readPreference\
    \ | advanced |  | ReadPreference | Sets a MongoDB ReadPreference on the Mongo\
    \ connection. Read preferences set directly on the connection will be overridden\
    \ by this setting. The link com.mongodb.ReadPreferencevalueOf(String) utility\
    \ method is used to resolve the passed readPreference value. Some examples for\
    \ the possible values are nearest primary or secondary etc.\n| synchronous | advanced\
    \ | false | boolean | Sets whether synchronous processing should be strictly used\
    \ or Camel is allowed to use asynchronous processing (if supported).\n| writeResultAsHeader\
    \ | advanced | false | boolean | In write operations it determines whether instead\
    \ of returning WriteResult as the body of the OUT message we transfer the IN message\
    \ to the OUT and attach the WriteResult as a header.\n| persistentId | tail |\
    \  | String | One tail tracking collection can host many trackers for several\
    \ tailable consumers. To keep them separate each tracker should have its own unique\
    \ persistentId.\n| persistentTailTracking | tail | false | boolean | Enable persistent\
    \ tail tracking which is a mechanism to keep track of the last consumed message\
    \ across system restarts. The next time the system is up the endpoint will recover\
    \ the cursor from the point where it last stopped slurping records.\n| tailTrackCollection\
    \ | tail |  | String | Collection where tail tracking information will be persisted.\
    \ If not specified link MongoDbTailTrackingConfigDEFAULT_COLLECTION will be used\
    \ by default.\n| tailTrackDb | tail |  | String | Indicates what database the\
    \ tail tracking mechanism will persist to. If not specified the current database\
    \ will be picked by default. Dynamicity will not be taken into account even if\
    \ enabled i.e. the tail tracking database will not vary past endpoint initialisation.\n\
    | tailTrackField | tail |  | String | Field where the last tracked value will\
    \ be placed. If not specified link MongoDbTailTrackingConfigDEFAULT_FIELD will\
    \ be used by default.\n| tailTrackIncreasingField | tail |  | String | Correlation\
    \ field in the incoming record which is of increasing nature and will be used\
    \ to position the tailing cursor every time it is generated. The cursor will be\
    \ (re)created with a query of type: tailTrackIncreasingField lastValue (possibly\
    \ recovered from persistent tail tracking). Can be of type Integer Date String\
    \ etc. NOTE: No support for dot notation at the current time so the field should\
    \ be at the top level of the document.\n|=======================================================================\n\
    {% endraw %}\n// endpoint options: END\n\n\n\n\n\n\n[[MongoDB-ConfigurationofdatabaseinSpringXML]]\n\
    Configuration of database in Spring XML\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nThe following Spring XML creates a bean defining the connection to a\nMongoDB\
    \ instance.\n\n[source,xml]\n----------------------------------------------------------------------------------------------------------------------------------\n\
    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\
    \n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\
    >\n    <bean id=\"mongoBean\" class=\"com.mongodb.Mongo\">\n        <constructor-arg\
    \ name=\"host\" value=\"${mongodb.host}\" />\n        <constructor-arg name=\"\
    port\" value=\"${mongodb.port}\" />\n    </bean>\n</beans>\n----------------------------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-Sampleroute]]\nSample route\n^^^^^^^^^^^^\n\nThe following route defined\
    \ in Spring XML executes the operation\nlink:mongodb.html[*dbStats*] on a collection.\n\
    \n*Get DB stats for specified collection*\n\n[source,xml]\n---------------------------------------------------------------------------------------------------------------------------\n\
    <route>\n  <from uri=\"direct:start\" />\n  <!-- using bean 'mongoBean' defined\
    \ above -->\n  <to uri=\"mongodb:mongoBean?database=${mongodb.database}&amp;collection=${mongodb.collection}&amp;operation=getDbStats\"\
    \ />\n  <to uri=\"direct:result\" />\n</route>\n---------------------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-MongoDBoperations-producerendpoints]]\nMongoDB operations - producer\
    \ endpoints\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n[[MongoDB-Queryoperations]]\n\
    Query operations\n^^^^^^^^^^^^^^^^\n\n[[MongoDB-findById]]\nfindById\n++++++++\n\
    \nThis operation retrieves only one element from the collection whose _id\nfield\
    \ matches the content of the IN message body. The incoming object\ncan be anything\
    \ that has an equivalent to a BSON type. See\nhttp://bsonspec.org/#/specification[http://bsonspec.org/#/specification]\n\
    and\nhttp://www.mongodb.org/display/DOCS/Java+Types[http://www.mongodb.org/display/DOCS/Java+Types].\n\
    \n[source,java]\n------------------------------------------------------------------------------\n\
    from(\"direct:findById\")\n    .to(\"mongodb:myDb?database=flights&collection=tickets&operation=findById\"\
    )\n    .to(\"mock:resultFindById\");\n------------------------------------------------------------------------------\n\
    \n\nTIP: *Supports optional parameters*. This operation supports specifying a\
    \ fields filter. See\nlink:mongodb.html[Specifying optional parameters].\n\n[[MongoDB-findOneByQuery]]\n\
    findOneByQuery\n++++++++++++++\n\nUse this operation to retrieve just one element\
    \ from the collection that\nmatches a MongoDB query. *The query object is extracted\
    \ from the IN\nmessage body*, i.e. it should be of type `DBObject` or convertible\
    \ to\n`DBObject`. It can be a JSON String or a Hashmap. See\nlink:mongodb.html[#Type\
    \ conversions] for more info.\n\nExample with no query (returns any object of\
    \ the collection):\n\n[source,java]\n------------------------------------------------------------------------------------\n\
    from(\"direct:findOneByQuery\")\n    .to(\"mongodb:myDb?database=flights&collection=tickets&operation=findOneByQuery\"\
    )\n    .to(\"mock:resultFindOneByQuery\");\n------------------------------------------------------------------------------------\n\
    \nExample with a query (returns one matching result):\n\n[source,java]\n------------------------------------------------------------------------------------\n\
    from(\"direct:findOneByQuery\")\n    .setBody().constant(\"{ \\\"name\\\": \\\"\
    Raul Kripalani\\\" }\")\n    .to(\"mongodb:myDb?database=flights&collection=tickets&operation=findOneByQuery\"\
    )\n    .to(\"mock:resultFindOneByQuery\");\n------------------------------------------------------------------------------------\n\
    \nTIP: *Supports optional parameters*. This operation supports specifying a fields\
    \ filter and/or a sort clause. See\nlink:mongodb.html[Specifying optional parameters].\n\
    \n[[MongoDB-findAll]]\nfindAll\n+++++++\n\nThe `findAll` operation returns all\
    \ documents matching a query, or none\nat all, in which case all documents contained\
    \ in the collection are\nreturned. *The query object is extracted from the IN\
    \ message body*, i.e.\nit should be of type `DBObject` or convertible to `DBObject`.\
    \ It can be\na JSON String or a Hashmap. See link:mongodb.html[#Type conversions]\
    \ for\nmore info.\n\nExample with no query (returns all object in the collection):\n\
    \n[source,java]\n-----------------------------------------------------------------------------\n\
    from(\"direct:findAll\")\n    .to(\"mongodb:myDb?database=flights&collection=tickets&operation=findAll\"\
    )\n    .to(\"mock:resultFindAll\");\n-----------------------------------------------------------------------------\n\
    \nExample with a query (returns all matching results):\n\n[source,java]\n-----------------------------------------------------------------------------\n\
    from(\"direct:findAll\")\n    .setBody().constant(\"{ \\\"name\\\": \\\"Raul Kripalani\\\
    \" }\")\n    .to(\"mongodb:myDb?database=flights&collection=tickets&operation=findAll\"\
    )\n    .to(\"mock:resultFindAll\");\n-----------------------------------------------------------------------------\n\
    \nPaging and efficient retrieval is supported via the following headers:\n\n[width=\"\
    100%\",cols=\"10%,10%,10%,70%\",options=\"header\",]\n|=======================================================================\n\
    |Header key |Quick constant |Description (extracted from MongoDB API doc) |Expected\
    \ type\n\n|`CamelMongoDbNumToSkip` |`MongoDbConstants.NUM_TO_SKIP` |Discards a\
    \ given number of elements at the beginning of the cursor. |int/Integer\n\n|`CamelMongoDbLimit`\
    \ |`MongoDbConstants.LIMIT` |Limits the number of elements returned. |int/Integer\n\
    \n|`CamelMongoDbBatchSize` |`MongoDbConstants.BATCH_SIZE` |Limits the number of\
    \ elements returned in one batch. A cursor typically\nfetches a batch of result\
    \ objects and store them locally. If batchSize\nis positive, it represents the\
    \ size of each batch of objects retrieved.\nIt can be adjusted to optimize performance\
    \ and limit data transfer. If\nbatchSize is negative, it will limit of number\
    \ objects returned, that\nfit within the max batch size limit (usually 4MB), and\
    \ cursor will be\nclosed. For example if batchSize is -10, then the server will\
    \ return a\nmaximum of 10 documents and as many as can fit in 4MB, then close\
    \ the\ncursor. Note that this feature is different from limit() in that\ndocuments\
    \ must fit within a maximum size, and it removes the need to\nsend a request to\
    \ close the cursor server-side. The batch size can be\nchanged even after a cursor\
    \ is iterated, in which case the setting will\napply on the next batch retrieval.\
    \ |int/Integer\n|=======================================================================\n\
    \nThe `findAll` operation will also return the following OUT headers to\nenable\
    \ you to iterate through result pages if you are using paging:\n\n[width=\"100%\"\
    ,cols=\"10%,10%,10%,70%\",options=\"header\",]\n|=======================================================================\n\
    |Header key |Quick constant |Description (extracted from MongoDB API doc) |Data\
    \ type\n\n|`CamelMongoDbResultTotalSize` |`MongoDbConstants.RESULT_TOTAL_SIZE`\
    \ |Number of objects matching the query. This does not take limit/skip into\n\
    consideration. |int/Integer\n\n|`CamelMongoDbResultPageSize` |`MongoDbConstants.RESULT_PAGE_SIZE`\
    \ |Number of objects matching the query. This does not take limit/skip into\n\
    consideration. |int/Integer\n|=======================================================================\n\
    \nTIP: *Supports optional parameters*. This operation supports specifying a fields\
    \ filter and/or a sort clause. See\nlink:mongodb.html[Specifying optional parameters].\n\
    \n[[MongoDB-count]]\ncount\n+++++\n\nReturns the total number of objects in a\
    \ collection, returning a Long as\nthe OUT message body. +\nThe following example\
    \ will count the number of records in the\n\"dynamicCollectionName\" collection.\
    \ Notice how dynamicity is enabled,\nand as a result, the operation will not run\
    \ against the\n\"notableScientists\" collection, but against the \"dynamicCollectionName\"\
    \ncollection.\n\n[source,java]\n------------------------------------------------------------------------------------------------------------------------------------\n\
    // from(\"direct:count\").to(\"mongodb:myDb?database=tickets&collection=flights&operation=count&dynamicity=true\"\
    );\nLong result = template.requestBodyAndHeader(\"direct:count\", \"irrelevantBody\"\
    , MongoDbConstants.COLLECTION, \"dynamicCollectionName\");\nassertTrue(\"Result\
    \ is not of type Long\", result instanceof Long);\n------------------------------------------------------------------------------------------------------------------------------------\n\
    \nFrom\_*Camel 2.14*\_onwards you can provide\na\_`com.mongodb.DBObject`\_object\
    \ in the message body as a query,\_and\noperation will return the amount of documents\
    \ matching this criteria.\_\n\n\_\n\n[source,java]\n------------------------------------------------------------------------------------------------------------------------\n\
    DBObject query = ...\nLong count = template.requestBodyAndHeader(\"direct:count\"\
    , query, MongoDbConstants.COLLECTION, \"dynamicCollectionName\");\n------------------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-Specifyingoptionalparameters]]\nSpecifying a fields filter (projection)\n\
    +++++++++++++++++++++++++++++++++++++++\n\nQuery operations will, by default,\
    \ return the matching objects in their\nentirety (with all their fields). If your\
    \ documents are large and you\nonly require retrieving a subset of their fields,\
    \ you can specify a\nfield filter in all query operations, simply by setting the\
    \ relevant\n`DBObject` (or type convertible to `DBObject`, such as a JSON String,\n\
    Map, etc.) on the `CamelMongoDbFieldsFilter` header, constant shortcut:\n`MongoDbConstants.FIELDS_FILTER`.\n\
    \nHere is an example that uses MongoDB's BasicDBObjectBuilder to simplify\nthe\
    \ creation of DBObjects. It retrieves all fields except `_id` and\n`boringField`:\n\
    \n[source,java]\n----------------------------------------------------------------------------------------------------------------------------\n\
    // route: from(\"direct:findAll\").to(\"mongodb:myDb?database=flights&collection=tickets&operation=findAll\"\
    )\nDBObject fieldFilter = BasicDBObjectBuilder.start().add(\"_id\", 0).add(\"\
    boringField\", 0).get();\nObject result = template.requestBodyAndHeader(\"direct:findAll\"\
    , (Object) null, MongoDbConstants.FIELDS_FILTER, fieldFilter);\n----------------------------------------------------------------------------------------------------------------------------\n\
    \nSpecifying a sort clause\n++++++++++++++++++++++++\n\nThere is a often a requirement\
    \ to fetch the min/max record from a \ncollection based on sorting by a particular\
    \ field. In Mongo the \noperation is performed using syntax similar to:\n\n[source]\n\
    ----------------------------------------------------------------------------------------------------------------------------\n\
    db.collection.find().sort({_id: -1}).limit(1)\n// or\ndb.collection.findOne({$query:{},$orderby:{_id:-1}})\n\
    ----------------------------------------------------------------------------------------------------------------------------\n\
    \nIn a Camel route the SORT_BY header can be used with the findOneByQuery \noperation\
    \ to achieve the same result. If the FIELDS_FILTER header is also\nspecified the\
    \ operation will return a single field/value pair \nthat can be passed directly\
    \ to another component (for example, a \nparameterized MyBatis SELECT query).\
    \ This example demonstrates fetching \nthe temporally newest document from a collection\
    \ and reducing the result \nto a single field, based on the `documentTimestamp`\
    \ field:\n\n[source,java]\n----------------------------------------------------------------------------------------------------------------------------\n\
    .from(\"direct:someTriggeringEvent\")\n.setHeader(MongoDbConstants.SORT_BY).constant(\"\
    {\\\"documentTimestamp\\\": -1}\")\n.setHeader(MongoDbConstants.FIELDS_FILTER).constant(\"\
    {\\\"documentTimestamp\\\": 1}\")\n.setBody().constant(\"{}\")\n.to(\"mongodb:myDb?database=local&collection=myDemoCollection&operation=findOneByQuery\"\
    )\n.to(\"direct:aMyBatisParameterizedSelect\")\n;\n----------------------------------------------------------------------------------------------------------------------------\n\
    \n\n[[MongoDB-Create/updateoperations]]\nCreate/update operations\n^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \n[[MongoDB-insert]]\ninsert\n++++++\n\nInserts an new object into the MongoDB\
    \ collection, taken from the IN\nmessage body. Type conversion is attempted to\
    \ turn it into `DBObject` or\na `List`. +\n Two modes are supported: single insert\
    \ and multiple insert. For\nmultiple insert, the endpoint will expect a List,\
    \ Array or Collections\nof objects of any type, as long as they are - or can be\
    \ converted to -\n`DBObject`. All objects are inserted at once. The endpoint will\n\
    intelligently decide which backend operation to invoke (single or\nmultiple insert)\
    \ depending on the input.\n\nExample:\n\n[source,java]\n-----------------------------------------------------------------------------\n\
    from(\"direct:insert\")\n    .to(\"mongodb:myDb?database=flights&collection=tickets&operation=insert\"\
    );\n-----------------------------------------------------------------------------\n\
    \nThe operation will return a WriteResult, and depending on the\n`WriteConcern`\
    \ or the value of the `invokeGetLastError` option,\n`getLastError()` would have\
    \ been called already or not. If you want to\naccess the ultimate result of the\
    \ write operation, you need to retrieve\nthe `CommandResult` by calling `getLastError()`\
    \ or\n`getCachedLastError()` on the `WriteResult`. Then you can verify the\nresult\
    \ by calling `CommandResult.ok()`,\n`CommandResult.getErrorMessage()` and/or `CommandResult.getException()`.\n\
    \nNote that the new object's `_id` must be unique in the collection. If\nyou don't\
    \ specify the value, MongoDB will automatically generate one for\nyou. But if\
    \ you do specify it and it is not unique, the insert operation\nwill fail (and\
    \ for Camel to notice, you will need to enable\ninvokeGetLastError or set a WriteConcern\
    \ that waits for the write\nresult).\n\nThis is not a limitation of the component,\
    \ but it is how things work in\nMongoDB for higher throughput. If you are using\
    \ a custom `_id`, you are\nexpected to ensure at the application level that is\
    \ unique (and this is\na good practice too).\n\nSince Camel *2.15*: OID(s) of\
    \ the inserted record(s) is stored in the\nmessage header under\_`CamelMongoOid`\
    \ key (`MongoDbConstants.OID`\nconstant). The value stored is\_`org.bson.types.ObjectId`\
    \ for single\ninsert or `java.util.List<org.bson.types.ObjectId>` if multiple\
    \ records\nhave been inserted.\n\n[[MongoDB-save]]\nsave\n++++\n\nThe save operation\
    \ is equivalent to an _upsert_ (UPdate, inSERT)\noperation, where the record will\
    \ be updated, and if it doesn't exist, it\nwill be inserted, all in one atomic\
    \ operation. MongoDB will perform the\nmatching based on the _id field.\n\nBeware\
    \ that in case of an update, the object is replaced entirely and\nthe usage of\n\
    http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations[MongoDB's\n\
    $modifiers] is not permitted. Therefore, if you want to manipulate the\nobject\
    \ if it already exists, you have two options:\n\n1.  perform a query to retrieve\
    \ the entire object first along with all\nits fields (may not be efficient), alter\
    \ it inside Camel and then save\nit.\n2.  use the update operation with\nhttp://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations[$modifiers],\n\
    which will execute the update at the server-side instead. You can enable\nthe\
    \ upsert flag, in which case if an insert is required, MongoDB will\napply the\
    \ $modifiers to the filter query object and insert the result.\n\nFor example:\n\
    \n[source,java]\n---------------------------------------------------------------------------\n\
    from(\"direct:insert\")\n    .to(\"mongodb:myDb?database=flights&collection=tickets&operation=save\"\
    );\n---------------------------------------------------------------------------\n\
    \n[[MongoDB-update]]\nupdate\n++++++\n\nUpdate one or multiple records on the\
    \ collection. Requires a\nList<DBObject> as the IN message body containing exactly\
    \ 2 elements:\n\n* Element 1 (index 0) => filter query => determines what objects\
    \ will be\naffected, same as a typical query object\n* Element 2 (index 1) =>\
    \ update rules => how matched objects will be\nupdated. All\nhttp://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations[modifier\n\
    operations] from MongoDB are supported.\n\nNOTE: *Multiupdates* . By default,\
    \ MongoDB will only update 1 object even if multiple objects\nmatch the filter\
    \ query. To instruct MongoDB to update *all* matching\nrecords, set the `CamelMongoDbMultiUpdate`\
    \ IN message header to `true`.\n\nA header with key `CamelMongoDbRecordsAffected`\
    \ will be returned\n(`MongoDbConstants.RECORDS_AFFECTED` constant) with the number\
    \ of\nrecords updated (copied from `WriteResult.getN()`).\n\nSupports the following\
    \ IN message headers:\n\n[width=\"100%\",cols=\"10%,10%,10%,70%\",options=\"header\"\
    ,]\n|=======================================================================\n\
    |Header key |Quick constant |Description (extracted from MongoDB API doc) |Expected\
    \ type\n\n|`CamelMongoDbMultiUpdate` |`MongoDbConstants.MULTIUPDATE` |If the update\
    \ should be applied to all objects matching. See\nhttp://www.mongodb.org/display/DOCS/Atomic+Operations[http://www.mongodb.org/display/DOCS/Atomic+Operations]\
    \ |boolean/Boolean\n\n|`CamelMongoDbUpsert` |`MongoDbConstants.UPSERT` |If the\
    \ database should create the element if it does not exist |boolean/Boolean\n|=======================================================================\n\
    \nFor example, the following will update *all* records whose filterField\nfield\
    \ equals true by setting the value of the \"scientist\" field to\n\"Darwin\":\n\
    \n[source,java]\n------------------------------------------------------------------------------------------------------------------------------------------\n\
    // route: from(\"direct:update\").to(\"mongodb:myDb?database=science&collection=notableScientists&operation=update\"\
    );\nDBObject filterField = new BasicDBObject(\"filterField\", true);\nDBObject\
    \ updateObj = new BasicDBObject(\"$set\", new BasicDBObject(\"scientist\", \"\
    Darwin\"));\nObject result = template.requestBodyAndHeader(\"direct:update\",\
    \ new Object[] {filterField, updateObj}, MongoDbConstants.MULTIUPDATE, true);\n\
    ------------------------------------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-Deleteoperations]]\nDelete operations\n^^^^^^^^^^^^^^^^^\n\n[[MongoDB-remove]]\n\
    remove\n++++++\n\nRemove matching records from the collection. The IN message\
    \ body will\nact as the removal filter query, and is expected to be of type\n\
    `DBObject` or a type convertible to it. +\n The following example will remove\
    \ all objects whose field\n'conditionField' equals true, in the science database,\
    \ notableScientists\ncollection:\n\n[source,java]\n------------------------------------------------------------------------------------------------------------------\n\
    // route: from(\"direct:remove\").to(\"mongodb:myDb?database=science&collection=notableScientists&operation=remove\"\
    );\nDBObject conditionField = new BasicDBObject(\"conditionField\", true);\nObject\
    \ result = template.requestBody(\"direct:remove\", conditionField);\n------------------------------------------------------------------------------------------------------------------\n\
    \nA header with key `CamelMongoDbRecordsAffected` is returned\n(`MongoDbConstants.RECORDS_AFFECTED`\
    \ constant) with type `int`,\ncontaining the number of records deleted (copied\
    \ from\n`WriteResult.getN()`).\n\n[[MongoDB-Otheroperations]]\nOther operations\n\
    ^^^^^^^^^^^^^^^^\n\n[[MongoDB-aggregate]]\naggregate\n+++++++++\n\n*Available\
    \ as of Camel 2.14*\n\nPerform a aggregation with the given pipeline contained\
    \ in the\nbody.\_*Aggregations could be long and heavy operations. Use with care.*\n\
    \n\_\n\n[source,java]\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\
    // route: from(\"direct:aggregate\").to(\"mongodb:myDb?database=science&collection=notableScientists&operation=aggregate\"\
    );\nfrom(\"direct:aggregate\")\n    .setBody().constant(\"[{ $match : {$or : [{\\\
    \"scientist\\\" : \\\"Darwin\\\"},{\\\"scientist\\\" : \\\"Einstein\\\"}]}},{\
    \ $group: { _id: \\\"$scientist\\\", count: { $sum: 1 }} } ]\")\n    .to(\"mongodb:myDb?database=science&collection=notableScientists&operation=aggregate\"\
    )\n    .to(\"mock:resultAggregate\");\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-getDbStats]]\ngetDbStats\n++++++++++\n\nEquivalent of running the\
    \ `db.stats()` command in the MongoDB shell,\nwhich displays useful statistic\
    \ figures about the database. +\n For example:\n\n[source,java]\n-------------------------------------\n\
    > db.stats();\n{\n    \"db\" : \"test\",\n    \"collections\" : 7,\n    \"objects\"\
    \ : 719,\n    \"avgObjSize\" : 59.73296244784423,\n    \"dataSize\" : 42948,\n\
    \    \"storageSize\" : 1000058880,\n    \"numExtents\" : 9,\n    \"indexes\" :\
    \ 4,\n    \"indexSize\" : 32704,\n    \"fileSize\" : 1275068416,\n    \"nsSizeMB\"\
    \ : 16,\n    \"ok\" : 1\n}\n-------------------------------------\n\nUsage example:\n\
    \n[source,java]\n---------------------------------------------------------------------------------------------------------\n\
    // from(\"direct:getDbStats\").to(\"mongodb:myDb?database=flights&collection=tickets&operation=getDbStats\"\
    );\nObject result = template.requestBody(\"direct:getDbStats\", \"irrelevantBody\"\
    );\nassertTrue(\"Result is not of type DBObject\", result instanceof DBObject);\n\
    ---------------------------------------------------------------------------------------------------------\n\
    \nThe operation will return a data structure similar to the one displayed\nin\
    \ the shell, in the form of a `DBObject` in the OUT message body.\n\n[[MongoDB-getColStats]]\n\
    getColStats\n+++++++++++\n\nEquivalent of running the `db.collection.stats()`\
    \ command in the MongoDB\nshell, which displays useful statistic figures about\
    \ the collection. +\n For example:\n\n[source,java]\n-----------------------------\n\
    > db.camelTest.stats();\n{\n    \"ns\" : \"test.camelTest\",\n    \"count\" :\
    \ 100,\n    \"size\" : 5792,\n    \"avgObjSize\" : 57.92,\n    \"storageSize\"\
    \ : 20480,\n    \"numExtents\" : 2,\n    \"nindexes\" : 1,\n    \"lastExtentSize\"\
    \ : 16384,\n    \"paddingFactor\" : 1,\n    \"flags\" : 1,\n    \"totalIndexSize\"\
    \ : 8176,\n    \"indexSizes\" : {\n        \"_id_\" : 8176\n    },\n    \"ok\"\
    \ : 1\n}\n-----------------------------\n\nUsage example:\n\n[source,java]\n-----------------------------------------------------------------------------------------------------------\n\
    // from(\"direct:getColStats\").to(\"mongodb:myDb?database=flights&collection=tickets&operation=getColStats\"\
    );\nObject result = template.requestBody(\"direct:getColStats\", \"irrelevantBody\"\
    );\nassertTrue(\"Result is not of type DBObject\", result instanceof DBObject);\n\
    -----------------------------------------------------------------------------------------------------------\n\
    \nThe operation will return a data structure similar to the one displayed\nin\
    \ the shell, in the form of a `DBObject` in the OUT message body.\n\n[[MongoDB-command]]\n\
    command\n+++++++\n\n*Available as of Camel 2.15*\n\nRun the body as a command\
    \ on database. Usefull for admin operation as\ngetting host informations, replication\
    \ or sharding status.\n\nCollection parameter is not use for this operation.\n\
    \n[source,java]\n--------------------------------------------------------------------------------\n\
    // route: from(\"command\").to(\"mongodb:myDb?database=science&operation=command\"\
    );\nDBObject commandBody = new BasicDBObject(\"hostInfo\", \"1\");\nObject result\
    \ = template.requestBody(\"direct:command\", commandBody);\n--------------------------------------------------------------------------------\n\
    \n[[MongoDB-Dynamicoperations]]\nDynamic operations\n^^^^^^^^^^^^^^^^^^\n\nAn\
    \ Exchange can override the endpoint's fixed operation by setting the\n`CamelMongoDbOperation`\
    \ header, defined by the\n`MongoDbConstants.OPERATION_HEADER` constant. +\n The\
    \ values supported are determined by the MongoDbOperation enumeration\nand match\
    \ the accepted values for the `operation` parameter on the\nendpoint URI.\n\n\
    For example:\n\n[source,java]\n-----------------------------------------------------------------------------------------------------------------------------\n\
    // from(\"direct:insert\").to(\"mongodb:myDb?database=flights&collection=tickets&operation=insert\"\
    );\nObject result = template.requestBodyAndHeader(\"direct:insert\", \"irrelevantBody\"\
    , MongoDbConstants.OPERATION_HEADER, \"count\");\nassertTrue(\"Result is not of\
    \ type Long\", result instanceof Long);\n-----------------------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-TailableCursorConsumer]]\nTailable Cursor Consumer\n~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nMongoDB offers a mechanism to instantaneously consume ongoing data from\na collection,\
    \ by keeping the cursor open just like the `tail -f` command\nof *nix systems.\
    \ This mechanism is significantly more efficient than a\nscheduled poll, due to\
    \ the fact that the server pushes new data to the\nclient as it becomes available,\
    \ rather than making the client ping back\nat scheduled intervals to fetch new\
    \ data. It also reduces otherwise\nredundant network traffic.\n\nThere is only\
    \ one requisite to use tailable cursors: the collection must\nbe a \"capped collection\"\
    , meaning that it will only hold N objects, and\nwhen the limit is reached, MongoDB\
    \ flushes old objects in the same order\nthey were originally inserted. For more\
    \ information, please refer to:\nhttp://www.mongodb.org/display/DOCS/Tailable+Cursors[http://www.mongodb.org/display/DOCS/Tailable+Cursors].\n\
    \nThe Camel MongoDB component implements a tailable cursor consumer,\nmaking this\
    \ feature available for you to use in your Camel routes. As\nnew objects are inserted,\
    \ MongoDB will push them as DBObjects in natural\norder to your tailable cursor\
    \ consumer, who will transform them to an\nExchange and will trigger your route\
    \ logic.\n\n[[MongoDB-Howthetailablecursorconsumerworks]]\nHow the tailable cursor\
    \ consumer works\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo turn a cursor into\
    \ a tailable cursor, a few special flags are to be\nsignalled to MongoDB when\
    \ first generating the cursor. Once created, the\ncursor will then stay open and\
    \ will block upon calling the\n`DBCursor.next()` method until new data arrives.\
    \ However, the MongoDB\nserver reserves itself the right to kill your cursor if\
    \ new data doesn't\nappear after an indeterminate period. If you are interested\
    \ to continue\nconsuming new data, you have to regenerate the cursor. And to do\
    \ so, you\nwill have to remember the position where you left off or else you will\n\
    start consuming from the top again.\n\nThe Camel MongoDB tailable cursor consumer\
    \ takes care of all these tasks\nfor you. You will just need to provide the key\
    \ to some field in your\ndata of increasing nature, which will act as a marker\
    \ to position your\ncursor every time it is regenerated, e.g. a timestamp, a sequential\
    \ ID,\netc. It can be of any datatype supported by MongoDB. Date, Strings and\n\
    Integers are found to work well. We call this mechanism \"tail tracking\"\nin\
    \ the context of this component.\n\nThe consumer will remember the last value\
    \ of this field and whenever the\ncursor is to be regenerated, it will run the\
    \ query with a filter like:\n`increasingField > lastValue`, so that only unread\
    \ data is consumed.\n\n*Setting the increasing field:* Set the key of the increasing\
    \ field on\nthe endpoint URI `tailTrackingIncreasingField` option. In Camel 2.10,\
    \ it\nmust be a top-level field in your data, as nested navigation for this\n\
    field is not yet supported. That is, the \"timestamp\" field is okay, but\n\"\
    nested.timestamp\" will not work. Please open a ticket in the Camel JIRA\nif you\
    \ do require support for nested increasing fields.\n\n*Cursor regeneration delay:*\
    \ One thing to note is that if new data is\nnot already available upon initialisation,\
    \ MongoDB will kill the cursor\ninstantly. Since we don't want to overwhelm the\
    \ server in this case, a\n`cursorRegenerationDelay` option has been introduced\
    \ (with a default\nvalue of 1000ms.), which you can modify to suit your needs.\n\
    \nAn example:\n\n[source,java]\n-----------------------------------------------------------------------------------------------------\n\
    from(\"mongodb:myDb?database=flights&collection=cancellations&tailTrackIncreasingField=departureTime\"\
    )\n    .id(\"tailableCursorConsumer1\")\n    .autoStartup(false)\n    .to(\"mock:test\"\
    );\n-----------------------------------------------------------------------------------------------------\n\
    \nThe above route will consume from the \"flights.cancellations\" capped\ncollection,\
    \ using \"departureTime\" as the increasing field, with a\ndefault regeneration\
    \ cursor delay of 1000ms.\n\n[[MongoDB-Persistenttailtracking]]\nPersistent tail\
    \ tracking\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nStandard tail tracking is volatile and\
    \ the last value is only kept in\nmemory. However, in practice you will need to\
    \ restart your Camel\ncontainer every now and then, but your last value would\
    \ then be lost and\nyour tailable cursor consumer would start consuming from the\
    \ top again,\nvery likely sending duplicate records into your route.\n\nTo overcome\
    \ this situation, you can enable the *persistent tail\ntracking* feature to keep\
    \ track of the last consumed increasing value in\na special collection inside\
    \ your MongoDB database too. When the consumer\ninitialises again, it will restore\
    \ the last tracked value and continue\nas if nothing happened.\n\nThe last read\
    \ value is persisted on two occasions: every time the cursor\nis regenerated and\
    \ when the consumer shuts down. We may consider\npersisting at regular intervals\
    \ too in the future (flush every 5\nseconds) for added robustness if the demand\
    \ is there. To request this\nfeature, please open a ticket in the Camel JIRA.\n\
    \n[[MongoDB-Enablingpersistenttailtracking]]\nEnabling persistent tail tracking\n\
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo enable this function, set at least the\
    \ following options on the\nendpoint URI:\n\n* `persistentTailTracking` option\
    \ to `true`\n* `persistentId` option to a unique identifier for this consumer,\
    \ so\nthat the same collection can be reused across many consumers\n\nAdditionally,\
    \ you can set the `tailTrackDb`, `tailTrackCollection` and\n`tailTrackField` options\
    \ to customise where the runtime information will\nbe stored. Refer to the endpoint\
    \ options table at the top of this page\nfor descriptions of each option.\n\n\
    For example, the following route will consume from the\n\"flights.cancellations\"\
    \ capped collection, using \"departureTime\" as the\nincreasing field, with a\
    \ default regeneration cursor delay of 1000ms,\nwith persistent tail tracking\
    \ turned on, and persisting under the\n\"cancellationsTracker\" id on the \"flights.camelTailTracking\"\
    , storing\nthe last processed value under the \"lastTrackingValue\" field\n(`camelTailTracking`\
    \ and `lastTrackingValue` are defaults).\n\n[source,java]\n-----------------------------------------------------------------------------------------------------------------------------------\n\
    from(\"mongodb:myDb?database=flights&collection=cancellations&tailTrackIncreasingField=departureTime&persistentTailTracking=true\"\
    \ + \n     \"&persistentId=cancellationsTracker\")\n    .id(\"tailableCursorConsumer2\"\
    )\n    .autoStartup(false)\n    .to(\"mock:test\");\n-----------------------------------------------------------------------------------------------------------------------------------\n\
    \nBelow is another example identical to the one above, but where the\npersistent\
    \ tail tracking runtime information will be stored under the\n\"trackers.camelTrackers\"\
    \ collection, in the \"lastProcessedDepartureTime\"\nfield:\n\n[source,java]\n\
    -----------------------------------------------------------------------------------------------------------------------------------\n\
    from(\"mongodb:myDb?database=flights&collection=cancellations&tailTrackIncreasingField=departureTime&persistentTailTracking=true\"\
    \ + \n     \"&persistentId=cancellationsTracker&tailTrackDb=trackers&tailTrackCollection=camelTrackers\"\
    \ + \n     \"&tailTrackField=lastProcessedDepartureTime\")\n    .id(\"tailableCursorConsumer3\"\
    )\n    .autoStartup(false)\n    .to(\"mock:test\");\n-----------------------------------------------------------------------------------------------------------------------------------\n\
    \n[[MongoDB-Typeconversions]]\nType conversions\n~~~~~~~~~~~~~~~~\n\nThe `MongoDbBasicConverters`\
    \ type converter included with the\ncamel-mongodb component provides the following\
    \ conversions:\n\n[width=\"100%\",cols=\"10%,10%,10%,70%\",options=\"header\"\
    ,]\n|=======================================================================\n\
    |Name |From type |To type |How?\n\n|fromMapToDBObject |`Map` |`DBObject` |constructs\
    \ a new `BasicDBObject` via the `new BasicDBObject(Map m)`\nconstructor\n\n|fromBasicDBObjectToMap\
    \ |`BasicDBObject` |`Map` |`BasicDBObject` already implements `Map`\n\n|fromStringToDBObject\
    \ |`String` |`DBObject` |uses `com.mongodb.util.JSON.parse(String s)`\n\n|fromAnyObjectToDBObject\
    \ |`Object`\_ |`DBObject` |uses the http://jackson.codehaus.org/[Jackson library]\
    \ to convert the\nobject to a `Map`, which is in turn used to initialise a new\n\
    `BasicDBObject`\n|=======================================================================\n\
    \nThis type converter is auto-discovered, so you don't need to configure\nanything\
    \ manually.\n\n[[MongoDB-Seealso]]\nSee also\n~~~~~~~~\n\n* http://www.mongodb.org/[MongoDB\
    \ website]\n* http://en.wikipedia.org/wiki/NoSQL[NoSQL Wikipedia article]\n* http://api.mongodb.org/java/current/[MongoDB\
    \ Java driver API docs -\ncurrent version]\n*\nhttp://svn.apache.org/viewvc/camel/trunk/components/camel-mongodb/src/test/[Unit\n\
    tests] for more examples of usage\n\n"
