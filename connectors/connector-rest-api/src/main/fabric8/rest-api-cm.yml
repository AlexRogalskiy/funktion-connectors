---
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    funktion.fabric8.io/kind: Connector
  name: rest-api
data:
  deployment.yml: |
    ---
    apiVersion: extensions/v1beta1
    kind: Deployment
    metadata:
      labels:
        funktion.fabric8.io/kind: Subscription
        connector: rest-api
    spec:
      replicas: 1
      template:
        metadata:
          labels:
            funktion.fabric8.io/kind: Subscription
            connector: rest-api
        spec:
          containers:
          - image: funktion/connector-rest-api:${project.version}
            name: connector
  schema.yml: |
    ---
    component:
      kind: component
      scheme: rest-api
      syntax: rest-api:path/contextIdPattern
      title: REST API
      description: The rest-api component is used for providing Swagger API of the REST services which has been defined using the rest-dsl in Camel.
      label: core,rest
      deprecated: false
      async: false
      consumerOnly: true
      lenientProperties: true
      javaType: org.apache.camel.component.rest.RestApiComponent
      groupId: org.apache.camel
      artifactId: camel-core
      version: 2.18.3
    componentProperties: {}
    properties:
      path:
        kind: path
        group: consumer
        required: true
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The base path
        order: 0
      contextIdPattern:
        kind: path
        group: consumer
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: Optional CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern.
        order: 1
      apiComponentName:
        kind: parameter
        group: consumer
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The Camel Rest API component to use for generating the API of the REST services such as swagger.
        order: 2
      bridgeErrorHandler:
        kind: parameter
        group: consumer
        label: consumer
        type: boolean
        javaType: boolean
        optionalPrefix: consumer.
        deprecated: false
        secret: false
        defaultValue: false
        description: Allows for bridging the consumer to the Camel routing Error Handler which mean any exceptions occurred while the consumer is trying to pickup incoming messages or the likes will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions that will be logged at WARN/ERROR level and ignored.
        order: 3
      componentName:
        kind: parameter
        group: consumer
        type: string
        javaType: java.lang.String
        deprecated: false
        secret: false
        description: The Camel Rest component to use for the REST transport such as restlet spark-rest. If no component has been explicit configured then Camel will lookup if there is a Camel component that integrates with the Rest DSL or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found then that is being used.
        order: 4
      exceptionHandler:
        kind: parameter
        group: consumer (advanced)
        label: consumer,advanced
        type: object
        javaType: org.apache.camel.spi.ExceptionHandler
        optionalPrefix: consumer.
        deprecated: false
        secret: false
        description: To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions that will be logged at WARN/ERROR level and ignored.
        order: 5
      exchangePattern:
        kind: parameter
        group: consumer (advanced)
        label: consumer,advanced
        type: string
        javaType: org.apache.camel.ExchangePattern
        enum:
        - InOnly
        - RobustInOnly
        - InOut
        - InOptionalOut
        - OutOnly
        - RobustOutOnly
        - OutIn
        - OutOptionalIn
        deprecated: false
        secret: false
        description: Sets the default exchange pattern when creating an exchange.
        order: 6
      synchronous:
        kind: parameter
        group: advanced
        label: advanced
        type: boolean
        javaType: boolean
        deprecated: false
        secret: false
        defaultValue: false
        description: Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).
        order: 7
  documentation.adoc: "[[RestDSL-RestDSL]]\nRest DSL\n~~~~~~~~\n\n*Available as of\
    \ Camel 2.14*\n\nApache Camel offers a REST styled DSL which can be used with\
    \ Java or\nXML. The intention is to allow end users to define REST services using\
    \ a\nREST style with verbs such as get, post, delete etc.\n\n[[RestDSL-Howitworks]]\n\
    How it works\n++++++++++++\n\nThe Rest DSL is a facade that builds link:rest.html[Rest]\_\
    endpoints as\nconsumers for Camel routes. The actual REST transport is leveraged\
    \ by\nusing Camel REST components such\nas\_link:restlet.html[Restlet],\_link:spark-rest.html[Spark-rest],\
    \ and\nothers that has native REST integration.\n\n[[RestDSL-ComponentssupportingRestDSL]]\n\
    Components supporting Rest DSL\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe following\
    \ Camel components supports the Rest DSL. See the bottom of\nthis page for how\
    \ to integrate a component with the Rest DSL.\n\n* camel-coap\n* link:netty-http.html[camel-netty-http]\_\
    (also\nsupports\_link:swagger-java.html[Swagger Java])\n* link:netty4-http.html[camel-netty4-http]\_\
    (also\nsupports\_link:swagger-java.html[Swagger Java])\n* link:jetty.html[camel-jetty]\_\
    (also\nsupports\_link:swagger-java.html[Swagger Java])\n* link:restlet.html[camel-restlet]\_\
    (also\nsupports\_link:swagger-java.html[Swagger Java])\n* link:servlet.html[camel-servlet]\_\
    (also\nsupports\_link:swagger-java.html[Swagger Java])\n* link:spark-rest.html[camel-spark-rest]\_\
    (also\nsupports\_link:swagger-java.html[Swagger Java]\_from Camel 2.17 onwards)\n\
    * link:undertow.html[camel-undertow]\_(also\nsupports\_link:swagger-java.html[Swagger\
    \ Java]\_from Camel 2.17 onwards)\n\n[[RestDSL-RestDSLwithJava]]\nRest DSL with\
    \ Java\n^^^^^^^^^^^^^^^^^^\n\nTo use the Rest DSL in Java then just do as with\
    \ regular Camel routes by\nextending the\_`RouteBuilder` and define the routes\
    \ in the\_`configure`\nmethod.\n\nA simple REST service can be define as follows,\
    \ where we use rest() to\ndefine the services as shown below:\n\n[source,java]\n\
    ------------------------------------------------------------------------------\n\
    \    protected RouteBuilder createRouteBuilder() throws Exception {\n        return\
    \ new RouteBuilder() {\n            @Override\n            public void configure()\
    \ throws Exception {\n                rest(\"/say\")\n                    .get(\"\
    /hello\").to(\"direct:hello\")\n                    .get(\"/bye\").consumes(\"\
    application/json\").to(\"direct:bye\")\n                    .post(\"/bye\").to(\"\
    mock:update\");\n\n                from(\"direct:hello\")\n                  \
    \  .transform().constant(\"Hello World\");\n                from(\"direct:bye\"\
    )\n                    .transform().constant(\"Bye World\");\n            }\n\
    \        };\n    }\n------------------------------------------------------------------------------\n\
    \n\_\n\nThis defines a REST service with the following url mappings:\n\n[width=\"\
    100%\",cols=\"25%,25%,25%,25%\",options=\"header\",]\n|=======================================================================\n\
    |Base Path |Uri template |Verb |Consumes\n\n|/say |/hello |get |_all_\n\n|/say\
    \ |/bye |get |application/json\n\n|/say |/bye |post |_all_\n|=======================================================================\n\
    \nNotice that in the REST service we route directly to a Camel endpoint\nusing\
    \ the to(). This is because the Rest DSL has a short-hand for\nrouting directly\
    \ to an endpoint using to(). An alternative is to embed a\nCamel route directly\
    \ using route() - there is such an example further\nbelow.\n\n[[RestDSL-RestDSLwithXML]]\n\
    Rest DSL with XML\n^^^^^^^^^^^^^^^^^\n\nThe REST DSL supports the XML DSL also\
    \ using either Spring or Blueprint.\nThe example above can be define in XML as\
    \ shown below:\n\n[source,java]\n--------------------------------------------------------------\n\
    \  <camelContext xmlns=\"http://camel.apache.org/schema/spring\">\n    <rest path=\"\
    /say\">\n      <get uri=\"/hello\">\n        <to uri=\"direct:hello\"/>\n    \
    \  </get>\n      <get uri=\"/bye\" consumes=\"application/json\">\n        <to\
    \ uri=\"direct:bye\"/>\n      </get>\n      <post uri=\"/bye\">\n        <to uri=\"\
    mock:update\"/>\n      </post>\n    </rest>\n    <route>\n      <from uri=\"direct:hello\"\
    />\n      <transform>\n        <constant>Hello World</constant>\n      </transform>\n\
    \    </route>\n    <route>\n      <from uri=\"direct:bye\"/>\n      <transform>\n\
    \        <constant>Bye World</constant>\n      </transform>\n    </route>\n  </camelContext>\n\
    --------------------------------------------------------------\n\n\_\n\n[[RestDSL-Usingbasepath]]\n\
    Using base path\n^^^^^^^^^^^^^^^\n\nThe REST DSL allows to define base path to\
    \ make the DSL a bit more DRY.\nFor example to define a customer path, we can\
    \ set the base path in\nrest(\"/customer\") and then provide the uri templates\
    \ in the verbs, as\nshown below:\n\n[source,java]\n-------------------------------------------------------\n\
    \  rest(\"/customers/\")\n      .get(\"/{id}\").to(\"direct:customerDetail\")\n\
    \      .get(\"/{id}/orders\").to(\"direct:customerOrders\")\n      .post(\"/neworder\"\
    ).to(\"direct:customerNewOrder\");\n-------------------------------------------------------\n\
    \n\_\n\nAnd using XML DSL it becomes:\n\n[source,java]\n-------------------------------------------\n\
    \    <rest path=\"/customers/\">\n      <get uri=\"/{id}\">\n        <to uri=\"\
    direct:customerDetail\"/>\n      </get>\n      <get uri=\"/{id}/orders\">\n  \
    \      <to uri=\"direct:customerOrders\"/>\n      </get>\n      <post uri=\"/neworder\"\
    >\n        <to uri=\"direct:customerNewOrder\"/>\n      </post>\n    </rest>\n\
    -------------------------------------------\n\nTIP:The REST DSL will take care\
    \ of duplicate path separators when using base\npath and uri templates. In the\
    \ example above the rest base path ends\nwith a slash ( / ) and the verb starts\
    \ with a slash ( / ). But Apache\nCamel will take care of this and remove the\
    \ duplicated slash.\n\nIt is not required to use both base path and uri templates.\
    \ You can omit\nthe bast path and define the base path and uri template in the\
    \ verbs\nonly. The example above can be defined as:\n\n[source,java]\n-------------------------------------------\n\
    \    <rest>\n      <get uri=\"/customers/{id}\">\n        <to uri=\"direct:customerDetail\"\
    />\n      </get>\n      <get uri=\"/customers/{id}/orders\">\n        <to uri=\"\
    direct:customerOrders\"/>\n      </get>\n      <post uri=\"/customers/neworder\"\
    >\n        <to uri=\"direct:customerNewOrder\"/>\n      </post>\n    </rest>\n\
    -------------------------------------------\n\n[[RestDSL-UsingDynamicTo]]\nUsing\
    \ Dynamic To\n^^^^^^^^^^^^^^^^\n\n*Available as of Camel 2.16*\n\nThe\_link:rest-dsl.html[Rest\
    \ DSL] supports the new .toD <toD> as dynamic\nto in the rest-dsl. For example\
    \ to do a request/reply\nover\_link:jms.html[JMS] where the queue name is dynamic\
    \ defined\n\n[source,xml]\n-------------------------------------------------------------------------\n\
    \ public void configure() throws Exception {\n   rest(\"/say\")\n     .get(\"\
    /hello/{language}\").toD(\"jms:queue:hello-${header.language}\");\n}\n-------------------------------------------------------------------------\n\
    \n[[RestDSL-AndinXMLDSL]]\nAnd in XML DSL\n^^^^^^^^^^^^^^\n\n[source,xml]\n---------------------------------------------------\n\
    <rest uri=\"/say\">\n  <get uri=\"/hello//{language}\">\n    <toD uri=\"jms:queue:hello-${header.language}\"\
    />\n  </get>\n<rest>\n---------------------------------------------------\n\n\_\
    \n\nSee more details at\_link:message-endpoint.html[Message Endpoint] about\n\
    the dynamic to, and what syntax it supports. By default it uses\nthe\_link:simple.html[Simple]\
    \ language, but it has more power than so.\n\n[[RestDSL-EmbeddingCamelroutes]]\n\
    Embedding Camel routes\n^^^^^^^^^^^^^^^^^^^^^^\n\nEach of the rest service becomes\
    \ a Camel route,\_so in the first example\nwe have 2 x get and 1 x post REST service,\
    \ which each become a Camel\nroute. And we have 2 regular Camel routes, meaning\
    \ we have 3 + 2 = 5\nroutes in total.\_\n\nThere are two route modes with the\
    \ Rest DSL\n\n* mini using a singular to\n* embedding a Camel route using route\_\
    \n\nThe first example is using the former with a singular to. And that is\nwhy\
    \ we end up with 3 + 2 = 5 total routes.\n\nThe same example could use embedded\
    \ Camel routes, which is shown below:\n\n[source,java]\n-----------------------------------------------------------------------------------------------------------\n\
    \    protected RouteBuilder createRouteBuilder() throws Exception {\n        return\
    \ new RouteBuilder() {\n            @Override\n            public void configure()\
    \ throws Exception {\n                rest(\"/say/hello\")\n                 \
    \   .get().route().transform().constant(\"Hello World\");\n                rest(\"\
    /say/bye\")\n                    .get().consumes(\"application/json\").route().transform().constant(\"\
    Bye World\").endRest()\n                    .post().to(\"mock:update\");\n   \
    \     };\n    }\n-----------------------------------------------------------------------------------------------------------\n\
    \nIn the example above, we are embedding routes directly in the rest\nservice\
    \ using .route(). Notice we need to use .endRest() to tell Camel\nwhere the route\
    \ ends, so we can\__go back_ to the Rest DSL and continue\ndefining REST services.\n\
    \nTIP:*Configuring route options*\n\nIn the embedded route you can configure the\
    \ route settings such as\nrouteId, autoStartup and various other options you can\
    \ set on routes\ntoday.\n---------------------------------------------------------------------------------------------\n\
    .get().route().routeId(\"myRestRoute\").autoStartup(false).transform().constant(\"\
    Hello World\");\n---------------------------------------------------------------------------------------------\n\
    \n\n[[RestDSL-ManagingRestservices]]\nManaging Rest services\n^^^^^^^^^^^^^^^^^^^^^^\n\
    \nEach of the rest service becomes a Camel route, so in the first example\nwe\
    \ have 2 x get and 1 x post REST service, which each become a Camel\nroute. This\
    \ makes it\__the same_ from Camel to manage and run these\nservices - as they\
    \ are just Camel routes. This means any tooling and API\ntoday that deals with\
    \ Camel routes, also work with the REST services.\n\nThis means you can use JMX\
    \ to stop/start routes, and also get the JMX\nmetrics about the routes, such as\
    \ number of message processed, and their\nperformance statistics.\n\nThere is\
    \ also a Rest Registry JMX MBean that contains a registry of all\nREST services\
    \ which has been defined.\_\n\n[[RestDSL-BindingtoPOJOsusing]]\nBinding to POJOs\
    \ using\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe Rest DSL supports automatic binding json/xml\
    \ contents to/from POJOs\nusing Camels\_link:data-format.html[Data Format]. By\
    \ default the binding\nmode is off, meaning there is no automatic binding happening\
    \ for\nincoming and outgoing messages.\n\nYou may want to use binding if you develop\
    \ POJOs that maps to your REST\nservices request and response types. This allows\
    \ you as a developer to\nwork with the POJOs in Java code.\n\nThe binding modes\
    \ are:\n\n[width=\"100%\",cols=\"10%,90%\",options=\"header\",]\n|=======================================================================\n\
    |Binding Mode |Description\n\n|off |Binding is turned off. This is the default\
    \ option.\n\n|auto |Binding is enabled and Camel is relaxed and support json,\
    \ xml or both if\nthe needed data formats are included in the classpath. Notice\
    \ that if\nfor example `camel-jaxb` is not on the classpath, then XML binding\
    \ is\nnot enabled.\n\n|json |Binding to/from json is enabled, and requires a json\
    \ capabile data\nformat on the classpath. By default Camel will use `json-jackson`\
    \ as the\ndata format. See the INFO box below for more details.\n\n|xml |Binding\
    \ to/from xml is enabled, and requires `camel-jaxb` on the\nclasspath. See the\
    \ INFO box below for more details.\n\n|json_xml |Biding to/from json and xml is\
    \ enabled and requires both data formats to\nbe on the classpath. See the INFO\
    \ box below for more details.\n|=======================================================================\n\
    \nTIP:From *Camel 2.14.1* onwards when using camel-jaxb for xml bindings, then\n\
    you can use the option `mustBeJAXBElement` to relax the output message\nbody must\
    \ be a class with JAXB annotations. You can use this in\nsituations where the\
    \ message body is already in XML format, and you want\nto use the message body\
    \ as-is as the output type. If that is the case,\nthen set the dataFormatProperty\
    \ option `mustBeJAXBElement` to `false`\nvalue.\n\nINFO:From\_*Camel 2.16.3*\_\
    onwards the binding from POJO to JSon/JAXB will only\nhappen if the\_`content-type`\_\
    header includes the\nword\_`json`\_or\_`xml`\_representatively. This allows you\
    \ to specify a\ncustom content-type if the message body should not attempt to\
    \ be\nmarshalled using the binding. For example if the message body is a\ncustom\
    \ binary payload etc.\n\nTo use binding you must include the necessary data formats\
    \ on the\nclasspath, such as\_`camel-jaxb` and/or\_`camel-jackson`. And then enable\n\
    the binding mode. You can configure the binding mode globally on the\nrest configuration,\
    \ and then override per rest service as well.\n\nTo enable binding you configure\
    \ this in Java DSL as shown below\n\n[source,java]\n-----------------------------------------------------------------------------------------------------------\n\
    restConfiguration().component(\"restlet\").host(\"localhost\").port(portNum).bindingMode(RestBindingMode.auto);\n\
    -----------------------------------------------------------------------------------------------------------\n\
    \nAnd in XML DSL\n\n[source,java]\n---------------------------------------------------------------------------\n\
    \    <restConfiguration bindingMode=\"auto\" component=\"restlet\" port=\"8080\"\
    />\n---------------------------------------------------------------------------\n\
    \n\_\n\nWhen binding is enabled Camel will bind the incoming and outgoing\nmessages\
    \ automatic, accordingly to the content type of the message. If\nthe message is\
    \ json, then json binding happens; and so if the message is\nxml then xml binding\
    \ happens. The binding happens for incoming and reply\nmessages. The table below\
    \ summaries what binding occurs for incoming and\nreply messages.\_\n\n[width=\"\
    100%\",cols=\"25%,25%,25%,25%\",options=\"header\",]\n|=======================================================================\n\
    |Message Body |Direction |Binding Mode |Message Body\n\n|XML |Incoming |auto,\n\
    xml,  \njson_xml\_|POJO\n\n|POJO |Outgoing |auto, \nxml, json_xml\_|XML\n\n|JSON\
    \ |Incoming |auto,\njson,\njson_xml\_|POJO\n\n|POJO |Outgoing |auto,\njson, \n\
    json_xml\_|JSON\n|=======================================================================\n\
    \_\nWhen using binding you must also configure what POJO type to map to.\nThis\
    \ is mandatory for incoming messages, and optional for outgoing.\_\n\nFor example\
    \ to map from xml/json to a pojo class\_`UserPojo` you do this\nin Java DSL as\
    \ shown below:\n\n[source,java]\n-----------------------------------------------------------------------------------------------------------\n\
    // configure to use restlet on localhost with the given port\n// and enable auto\
    \ binding mode\nrestConfiguration().component(\"restlet\").host(\"localhost\"\
    ).port(portNum).bindingMode(RestBindingMode.auto);\n\n// use the rest DSL to define\
    \ the rest services\nrest(\"/users/\")\n    .post().type(UserPojo.class)\n   \
    \     .to(\"direct:newUser\");\n-----------------------------------------------------------------------------------------------------------\n\
    \nNotice we use\_`type` to define the incoming type. We can optionally\ndefine\
    \ an outgoing type (which can be a good idea, to make it known from\nthe DSL and\
    \ also for tooling and JMX APIs to know both the incoming and\noutgoing types\
    \ of the REST services.). To define the outgoing type, we\nuse\_`outType` as shown\
    \ below:\n\n[source,java]\n-----------------------------------------------------------------------------------------------------------\n\
    // configure to use restlet on localhost with the given port\n// and enable auto\
    \ binding mode\nrestConfiguration().component(\"restlet\").host(\"localhost\"\
    ).port(portNum).bindingMode(RestBindingMode.auto);\n\n// use the rest DSL to define\
    \ the rest services\nrest(\"/users/\")\n    .post().type(UserPojo.class).outType(CountryPojo.class)\n\
    \        .to(\"direct:newUser\");\n-----------------------------------------------------------------------------------------------------------\n\
    \nThe\_`UserPojo` is just a plain pojo with getter/setter as shown:\n\n[source,java]\n\
    --------------------------------------\npublic class UserPojo {\n    private int\
    \ id;\n    private String name;\n    public int getId() {\n        return id;\n\
    \    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    public\
    \ String getName() {\n        return name;\n    }\n    public void setName(String\
    \ name) {\n        this.name = name;\n    }\n}\n--------------------------------------\n\
    \nThe\_`UserPojo` only supports json, as XML requires to use JAXB\nannotations,\
    \ so we can add those annotations if we want to support XML\nalso\n\n[source,java]\n\
    --------------------------------------\n@XmlRootElement(name = \"user\")\n@XmlAccessorType(XmlAccessType.FIELD)\n\
    public class UserPojo {\n    @XmlAttribute\n    private int id;\n    @XmlAttribute\n\
    \    private String name;\n    public int getId() {\n        return id;\n    }\n\
    \    public void setId(int id) {\n        this.id = id;\n    }\n    public String\
    \ getName() {\n        return name;\n    }\n    public void setName(String name)\
    \ {\n        this.name = name;\n    }\n}\n--------------------------------------\n\
    \nBy having the JAXB annotations the POJO supports both json and xml\nbindings.\n\
    \n[[RestDSL-ConfiguringRestDSL]]\nConfiguring Rest DSL\n^^^^^^^^^^^^^^^^^^^^\n\
    \n\n// component options: START\nThe REST API component has no options.\n// component\
    \ options: END\n\n\n\n// endpoint options: START\nThe REST API component supports\
    \ 8 endpoint options which are listed below:\n\n{% raw %}\n[width=\"100%\",cols=\"\
    2,1,1m,1m,5\",options=\"header\"]\n|=======================================================================\n\
    | Name | Group | Default | Java Type | Description\n| path | consumer |  | String\
    \ | *Required* The base path\n| contextIdPattern | consumer |  | String | Optional\
    \ CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's\
    \ which name matches the pattern.\n| apiComponentName | consumer |  | String |\
    \ The Camel Rest API component to use for generating the API of the REST services\
    \ such as swagger.\n| bridgeErrorHandler | consumer | false | boolean | Allows\
    \ for bridging the consumer to the Camel routing Error Handler which mean any\
    \ exceptions occurred while the consumer is trying to pickup incoming messages\
    \ or the likes will now be processed as a message and handled by the routing Error\
    \ Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler\
    \ to deal with exceptions that will be logged at WARN/ERROR level and ignored.\n\
    | componentName | consumer |  | String | The Camel Rest component to use for the\
    \ REST transport such as restlet spark-rest. If no component has been explicit\
    \ configured then Camel will lookup if there is a Camel component that integrates\
    \ with the Rest DSL or if a org.apache.camel.spi.RestConsumerFactory is registered\
    \ in the registry. If either one is found then that is being used.\n| exceptionHandler\
    \ | consumer (advanced) |  | ExceptionHandler | To let the consumer use a custom\
    \ ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this\
    \ options is not in use. By default the consumer will deal with exceptions that\
    \ will be logged at WARN/ERROR level and ignored.\n| exchangePattern | consumer\
    \ (advanced) |  | ExchangePattern | Sets the default exchange pattern when creating\
    \ an exchange.\n| synchronous | advanced | false | boolean | Sets whether synchronous\
    \ processing should be strictly used or Camel is allowed to use asynchronous processing\
    \ (if supported).\n|=======================================================================\n\
    {% endraw %}\n// endpoint options: END\n\n\nYou can configure properties on these\
    \ levels.\_\n\n* component - Is used to set any options on the Component class.\
    \ You can\nalso configure these directly on the component.\n* endpoint - Is used\
    \ set any option on the endpoint level. Many of the\nCamel components has many\
    \ options you can set on endpoint level.\n* consumer - Is used to set any option\
    \ on the consumer level. Some\ncomponents has consumer options, which you can\
    \ also configure from\nendpoint level by prefixing the option with \"consumer.\"\
    \_\n* data format - Is used to set any option on the data formats. For\nexample\
    \ to enable pretty print in the json data format.\n* cors headers - If cors is\
    \ enabled, then custom CORS headers can be\nset. See below for the default values\
    \ which are in used. If a custom\nheader is set then that value takes precedence\
    \ over the default value.\n\nYou can set multiple options of the same level, so\
    \ you can can for\nexample configure 2 component options, and 3 endpoint options\
    \ etc.\n\n\_\n\n[[RestDSL-EnablingordisablingJacksonJSONfeatures]]\nEnabling or\
    \ disabling Jackson JSON features\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \n*Available as of Camel 2.15*\n\nWhen using JSON binding you may want to turn\
    \ specific Jackson features\non or off. For example to disable failing on unknown\
    \ properties (eg json\ninput has a property which cannot be mapped to a POJO)\
    \ then configure\nthis using the dataFormatProperty as shown below:\n\n[source,java]\n\
    ----------------------------------------------------------------------------------------------------------\n\
    restConfiguration().component(\"jetty\").host(\"localhost\").port(getPort()).bindingMode(RestBindingMode.json)\n\
    \   .dataFormatProperty(\"json.in.disableFeatures\", \"FAIL_ON_UNKNOWN_PROPERTIES\"\
    );\n----------------------------------------------------------------------------------------------------------\n\
    \nYou can disable more features by separating the values using comma, such\nas:\n\
    \n[source,java]\n------------------------------------------------------------------------------------------------------------------\n\
    \   .dataFormatProperty(\"json.in.disableFeatures\", \"FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE\"\
    );\n------------------------------------------------------------------------------------------------------------------\n\
    \nLikewise you can enable features using the enableFeatures such as:\n\n[source,java]\n\
    -----------------------------------------------------------------------------------------------------------------\n\
    restConfiguration().component(\"jetty\").host(\"localhost\").port(getPort()).bindingMode(RestBindingMode.json)\n\
    \   .dataFormatProperty(\"json.in.disableFeatures\", \"FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE\"\
    )\n   .dataFormatProperty(\"json.in.enableFeatures\", \"FAIL_ON_NUMBERS_FOR_ENUMS,USE_BIG_DECIMAL_FOR_FLOATS\"\
    );\n-----------------------------------------------------------------------------------------------------------------\n\
    \nThe values that can be used for enabling and disabling features on\nJackson\
    \ are the names of the enums from the following three Jackson\nclasses\n\n* com.fasterxml.jackson.databind.SerializationFeature\n\
    * com.fasterxml.jackson.databind.DeserializationFeature\n* com.fasterxml.jackson.databind.MapperFeature\n\
    \n\_\n\nThe rest configuration is of course also possible using XML DSL\n\n[source,xml]\n\
    --------------------------------------------------------------------------------------------------------------------------\n\
    <restConfiguration component=\"jetty\" host=\"localhost\" port=\"9090\" bindingMode=\"\
    json\">\n  <dataFormatProperty key=\"json.in.disableFeatures\" value=\"FAIL_ON_UNKNOWN_PROPERTIES,ADJUST_DATES_TO_CONTEXT_TIME_ZONE\"\
    />\n  <dataFormatProperty key=\"json.in.enableFeatures\" value=\"FAIL_ON_NUMBERS_FOR_ENUMS,USE_BIG_DECIMAL_FOR_FLOATS\"\
    />\n</restConfiguration>\n--------------------------------------------------------------------------------------------------------------------------\n\
    \n\_\n\n[[RestDSL-DefaultCORSheaders]]\nDefault CORS headers\n^^^^^^^^^^^^^^^^^^^^\n\
    \n*Available as of Camel 2.14.1*\n\nIf CORS is enabled then the follow headers\
    \ is in use by default. You can\nconfigure custom CORS headers which takes precedence\
    \ over the default\nvalue.\n\n[width=\"100%\",cols=\"50%,50%\",options=\"header\"\
    ,]\n|=======================================================================\n\
    |Key |Value\n\n|Access-Control-Allow-Origin |*\n\n|Access-Control-Allow-Methods\
    \ |GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATCH\n\n|Access-Control-Allow-Headers\
    \ |Origin, Accept, X-Requested-With, Content-Type,\nAccess-Control-Request-Method,\
    \ Access-Control-Request-Headers\n\n|Access-Control-Max-Age |3600\n|=======================================================================\n\
    \_\n[[RestDSL-Definingacustomerrormessageas-is]]\nDefining a custom error message\
    \ as-is\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you want to define custom\
    \ error messages to be sent back to the\nclient with a HTTP error code (eg such\
    \ as 400, 404 etc.) then\nfrom\_*Camel 2.14.1* onwards you just set a header with\
    \ the\nkey\_`Exchange.HTTP_RESPONSE_CODE` to the error code (must be 300+) such\n\
    as 404. And then the message body with any reply message, and optionally\nset\
    \ the content-type header as well. There is a little example shown\nbelow:\n\n\
    [source,java]\n---------------------------------------------------------------------------------------------------------------------------\n\
    \                restConfiguration().component(\"restlet\").host(\"localhost\"\
    ).port(portNum).bindingMode(RestBindingMode.json);\n                // use the\
    \ rest DSL to define the rest services\n                rest(\"/users/\")\n  \
    \                  .post(\"lives\").type(UserPojo.class).outType(CountryPojo.class)\n\
    \                        .route()\n                            .choice()\n   \
    \                             .when().simple(\"${body.id} < 100\")\n         \
    \                           .bean(new UserErrorService(), \"idToLowError\")\n\
    \                                .otherwise()\n                              \
    \      .bean(new UserService(), \"livesWhere\");\n---------------------------------------------------------------------------------------------------------------------------\n\
    \nIn this example if the input id is a number that is below 100, we want\nto send\
    \ back a custom error message, using the UserErrorService bean,\nwhich is implemented\
    \ as shown:\n\n[source,java]\n------------------------------------------------------------------------\n\
    public class UserErrorService {\n    public void idToLowError(Exchange exchange)\
    \ {\n        exchange.getIn().setBody(\"id value is too low\");\n        exchange.getIn().setHeader(Exchange.CONTENT_TYPE,\
    \ \"text/plain\");\n        exchange.getIn().setHeader(Exchange.HTTP_RESPONSE_CODE,\
    \ 400);\n    }\n}\n------------------------------------------------------------------------\n\
    \nIn the UserErrorService bean we build our custom error message, and set\nthe\
    \ HTTP error code to 400. This is important, as that tells rest-dsl\nthat this\
    \ is a custom error message, and the message should not use the\noutput pojo binding\
    \ (eg would otherwise bind to CountryPojo).\n\n[[RestDSL-CatchingJsonParserExceptionandreturningacustomerrormessage]]\n\
    Catching JsonParserException and returning a custom error message\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nFrom\_*Camel 2.14.1* onwards you return a custom message as-is (see\nprevious\
    \ section). So we can leverage this with Camel error handler to\ncatch JsonParserException,\
    \ handle that exception and build our custom\nresponse message. For example to\
    \ return a HTTP error code 400 with a\nhardcoded message, we can do as shown below:\n\
    \n[source,java]\n-------------------------------------------------------------\n\
    onException(JsonParseException.class)\n    .handled(true)\n    .setHeader(Exchange.HTTP_RESPONSE_CODE,\
    \ constant(400))\n    .setHeader(Exchange.CONTENT_TYPE, constant(\"text/plain\"\
    ))\n    .setBody().constant(\"Invalid json data\");\n-------------------------------------------------------------\n\
    \n\_\n\n[[RestDSL-ParameterdefaultValues]]\nParameter default Values\n^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nYou can specify default values for parameters in the rest-dsl, such as\nthe\
    \ verbose parameter below:\n\n[source,java]\n--------------------------------------------------------------------------------------------------------------------------------\n\
    \  rest(\"/customers/\")\n      .get(\"/{id}\").to(\"direct:customerDetail\")\n\
    \      .get(\"/{id}/orders\")\n        .param().name(\"verbose\").type(RestParamType.query).defaultValue(\"\
    false\").description(\"Verbose order details\").endParam()\n          .to(\"direct:customerOrders\"\
    )\n      .post(\"/neworder\").to(\"direct:customerNewOrder\");\n--------------------------------------------------------------------------------------------------------------------------------\n\
    \nFrom\_*Camel 2.17* onwards then the default value is automatic set as\nheader\
    \ on the incoming Camel\_`Message`. So if the call\nthe\_`/customers/id/orders`\
    \ do not include a query parameter with\nkey\_`verbose` then Camel will now include\
    \ a header with key\_`verbose`\nand the value\_`false` because it was declared\
    \ as the default value. This\nfunctionality is only applicable for query parameters.\n\
    \n[[RestDSL-IntegratingaCamelcomponentwithRestDSL]]\nIntegrating a Camel component\
    \ with Rest DSL\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAny Apache Camel\
    \ component can integrate with the Rest DSL if they can\nbe used as a REST service\
    \ (eg as a REST consumer in Camel lingo). To\nintegrate with the Rest DSL, then\
    \ the component should implement\nthe\_`org.apache.camel.spi.RestConsumerFactory`.\
    \ The Rest DSL will then\ninvoke the\_`createConsumer` method when it setup the\
    \ Camel routes from\nthe defined DSL. The component should then implement logic\
    \ to create a\nCamel consumer that exposes the REST services based on the given\n\
    parameters, such as path, verb, and other options. For example see the\nsource\
    \ code for camel-restlet, camel-spark-rest.\n\n[[RestDSL-SwaggerAPI]]\nSwagger\
    \ API\n^^^^^^^^^^^\n\nThe Rest DSL supports link:swagger-java.html[Swagger Java]\_\
    by\nthe\_`camel-swagger-java` module. See more details at\n\_link:swagger-java.html[Swagger]\_\
    and the\_`camel-swagger-java`\_example\nfrom the Apache Camel distribution.\n\n\
    From\_*Camel 2.16* onwards you can define each parameter fine grained\nwith details\
    \ such as name, description, data type, parameter type and so\non, using the <param>.\
    \ For example to define the id path parameter you\ncan do as shown below:\n\n\
    [source,xml]\n---------------------------------------------------------------------------------------\n\
    <!-- this is a rest GET to view an user by the given id -->\n<get uri=\"/{id}\"\
    \ outType=\"org.apache.camel.example.rest.User\">\n  <description>Find user by\
    \ id</description>\n  <param name=\"id\" type=\"path\" description=\"The id of\
    \ the user to get\" dataType=\"int\"/>\n  <to uri=\"bean:userService?method=getUser(${header.id})\"\
    />\n</get>\n---------------------------------------------------------------------------------------\n\
    \nAnd in Java DSL\n\n[source,java]\n------------------------------------------------------------------------------------------------------\n\
    .get(\"/{id}\").description(\"Find user by id\").outType(User.class)\n    .param().name(\"\
    id\").type(path).description(\"The id of the user to get\").dataType(\"int\").endParam()\n\
    \    .to(\"bean:userService?method=getUser(${header.id})\")\n------------------------------------------------------------------------------------------------------\n\
    \nThe body parameter type requires to use body as well for the name. For\nexample\
    \ a REST PUT operation to create/update an user could be done as:\n\n[source,xml]\n\
    -----------------------------------------------------------------------------\n\
    <!-- this is a rest PUT to create/update an user -->\n<put type=\"org.apache.camel.example.rest.User\"\
    >\n  <description>Updates or create a user</description>\n  <param name=\"body\"\
    \ type=\"body\" description=\"The user to update or create\"/>\n  <to uri=\"bean:userService?method=updateUser\"\
    />\n</put>\n-----------------------------------------------------------------------------\n\
    \nAnd in Java DSL\n\n[source,java]\n-------------------------------------------------------------------------------------------\n\
    .put().description(\"Updates or create a user\").type(User.class)\n    .param().name(\"\
    body\").type(body).description(\"The user to update or create\").endParam()\n\
    \    .to(\"bean:userService?method=updateUser\")\n-------------------------------------------------------------------------------------------\n\
    \n\_\n\nFor an example see the\_`examples/camel-example-servlet-rest-tomcat`\_\
    of\nthe Apache Camel distribution.\n\n[[RestDSL-SeeAlso]]\nSee Also\n^^^^^^^^\n\
    \n* link:dsl.html[DSL]\n* link:rest.html[Rest]\n* link:swagger-java.html[Swagger\
    \ Java]\n* link:spark-rest.html[Spark-rest]\n* link:how-do-i-import-rests-from-other-xml-files.html[How\
    \ do I import\nrests from other XML files]\n\n"
